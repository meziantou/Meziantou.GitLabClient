// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated
// </auto-generated>
// ------------------------------------------------------------------------------
#nullable enable
namespace Meziantou.GitLab
{
    public partial interface IGitLabClient
    {
        Meziantou.GitLab.IGitLabProjectsClient Projects
        {
            get;
        }
    }

    public partial interface IGitLabProjectsClient
    {
        /// <summary>
        ///   <para>URL: <c>POST /projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#create-project" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<Project> CreateAsync(Meziantou.GitLab.CreateProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>GET /projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#list-all-projects" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<Project> GetAll(Meziantou.GitLab.GetAllProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions));

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#get-single-project" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<Project?> GetByIdAsync(Meziantou.GitLab.GetByIdProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>GET /users/:user_id/projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#list-user-projects" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<Project> GetByUser(Meziantou.GitLab.GetByUserProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions));

        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/uploads</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#upload-a-file" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<RepositoryFileUploaded> UploadFileAsync(Meziantou.GitLab.UploadFileProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
    }

    public partial class GitLabClient : Meziantou.GitLab.IGitLabProjectsClient
    {
        /// <summary>
        ///   <para>URL: <c>POST /projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#create-project" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<Project> Meziantou.GitLab.IGitLabProjectsClient.CreateAsync(Meziantou.GitLab.CreateProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Projects_CreateAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#list-all-projects" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<Project> Meziantou.GitLab.IGitLabProjectsClient.GetAll(Meziantou.GitLab.GetAllProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions)
        {
            return this.Projects_GetAll(request, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#get-single-project" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<Project?> Meziantou.GitLab.IGitLabProjectsClient.GetByIdAsync(Meziantou.GitLab.GetByIdProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Projects_GetByIdAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:user_id/projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#list-user-projects" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<Project> Meziantou.GitLab.IGitLabProjectsClient.GetByUser(Meziantou.GitLab.GetByUserProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions)
        {
            return this.Projects_GetByUser(request, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/uploads</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#upload-a-file" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<RepositoryFileUploaded> Meziantou.GitLab.IGitLabProjectsClient.UploadFileAsync(Meziantou.GitLab.UploadFileProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Projects_UploadFileAsync(request, requestOptions, cancellationToken);
        }

        public Meziantou.GitLab.IGitLabProjectsClient Projects
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        ///   <para>URL: <c>POST /projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#create-project" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<Project> Projects_CreateAsync(Meziantou.GitLab.CreateProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Projects_CreateAsync_BuildUrl();
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Post;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                requestMessage.Content = new Meziantou.GitLab.Internals.JsonContent(request, Meziantou.GitLab.Serialization.JsonSerialization.Options);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    Project? result = await response.ToObjectAsync<Project>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'Project' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        private static string Projects_CreateAsync_BuildUrl()
        {
            string url;
            url = "projects";
            return url;
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#list-all-projects" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        private Meziantou.GitLab.PagedResponse<Project> Projects_GetAll(Meziantou.GitLab.GetAllProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            string url = Meziantou.GitLab.GitLabClient.Projects_GetAll_BuildUrl(request);
            return new Meziantou.GitLab.PagedResponse<Project>(this, url, requestOptions);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Projects_GetAll_BuildUrl(Meziantou.GitLab.GetAllProjectRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("projects");
                char separator = '?';
                if (request.Archived.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("archived=");
                    urlBuilder.AppendParameter(request.Archived.GetValueOrDefault());
                }

                if (request.Visibility.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("visibility=");
                    urlBuilder.AppendParameter(request.Visibility.GetValueOrDefault());
                }

                if ((!object.ReferenceEquals(request.Search, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("search=");
                    urlBuilder.AppendParameter(request.Search);
                }

                if (request.Simple.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("simple=");
                    urlBuilder.AppendParameter(request.Simple.GetValueOrDefault());
                }

                if (request.Owned.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("owned=");
                    urlBuilder.AppendParameter(request.Owned.GetValueOrDefault());
                }

                if (request.Membership.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("membership=");
                    urlBuilder.AppendParameter(request.Membership.GetValueOrDefault());
                }

                if (request.Starred.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("starred=");
                    urlBuilder.AppendParameter(request.Starred.GetValueOrDefault());
                }

                if (request.Statistics.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("statistics=");
                    urlBuilder.AppendParameter(request.Statistics.GetValueOrDefault());
                }

                if (request.WithIssuesEnabled.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("with_issues_enabled=");
                    urlBuilder.AppendParameter(request.WithIssuesEnabled.GetValueOrDefault());
                }

                if (request.WithMergeRequestsEnabled.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("with_merge_requests_enabled=");
                    urlBuilder.AppendParameter(request.WithMergeRequestsEnabled.GetValueOrDefault());
                }

                if (request.WikiChecksumFailed.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("wiki_checksum_failed=");
                    urlBuilder.AppendParameter(request.WikiChecksumFailed.GetValueOrDefault());
                }

                if (request.RepositoryChecksumFailed.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("repository_checksum_failed=");
                    urlBuilder.AppendParameter(request.RepositoryChecksumFailed.GetValueOrDefault());
                }

                if (request.MinAccessLevel.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("min_access_level=");
                    urlBuilder.AppendParameter(request.MinAccessLevel.GetValueOrDefault());
                }

                if (request.OrderBy.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("order_by=");
                    urlBuilder.AppendParameter(request.OrderBy.GetValueOrDefault());
                }

                if (request.Sort.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("sort=");
                    urlBuilder.AppendParameter(request.Sort.GetValueOrDefault());
                }

                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#get-single-project" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<Project?> Projects_GetByIdAsync(Meziantou.GitLab.GetByIdProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Projects_GetByIdAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Get;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    if ((response.StatusCode == System.Net.HttpStatusCode.NotFound))
                    {
                        return default;
                    }

                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    Project? result = await response.ToObjectAsync<Project>(cancellationToken).ConfigureAwait(false);
                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Projects_GetByIdAsync_BuildUrl(Meziantou.GitLab.GetByIdProjectRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("projects/");
                if (request.Id.HasValue)
                {
                    urlBuilder.AppendParameter(request.Id.GetValueOrDefault().ValueAsString);
                }

                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:user_id/projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#list-user-projects" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        private Meziantou.GitLab.PagedResponse<Project> Projects_GetByUser(Meziantou.GitLab.GetByUserProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            string url = Meziantou.GitLab.GitLabClient.Projects_GetByUser_BuildUrl(request);
            return new Meziantou.GitLab.PagedResponse<Project>(this, url, requestOptions);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Projects_GetByUser_BuildUrl(Meziantou.GitLab.GetByUserProjectRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("users/");
                if (request.UserId.HasValue)
                {
                    urlBuilder.AppendParameter(request.UserId.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/projects");
                char separator = '?';
                if (request.Archived.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("archived=");
                    urlBuilder.AppendParameter(request.Archived.GetValueOrDefault());
                }

                if (request.Visibility.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("visibility=");
                    urlBuilder.AppendParameter(request.Visibility.GetValueOrDefault());
                }

                if ((!object.ReferenceEquals(request.Search, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("search=");
                    urlBuilder.AppendParameter(request.Search);
                }

                if (request.Simple.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("simple=");
                    urlBuilder.AppendParameter(request.Simple.GetValueOrDefault());
                }

                if (request.Owned.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("owned=");
                    urlBuilder.AppendParameter(request.Owned.GetValueOrDefault());
                }

                if (request.Membership.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("membership=");
                    urlBuilder.AppendParameter(request.Membership.GetValueOrDefault());
                }

                if (request.Starred.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("starred=");
                    urlBuilder.AppendParameter(request.Starred.GetValueOrDefault());
                }

                if (request.Statistics.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("statistics=");
                    urlBuilder.AppendParameter(request.Statistics.GetValueOrDefault());
                }

                if (request.WithIssuesEnabled.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("with_issues_enabled=");
                    urlBuilder.AppendParameter(request.WithIssuesEnabled.GetValueOrDefault());
                }

                if (request.WithMergeRequestsEnabled.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("with_merge_requests_enabled=");
                    urlBuilder.AppendParameter(request.WithMergeRequestsEnabled.GetValueOrDefault());
                }

                if (request.MinAccessLevel.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("min_access_level=");
                    urlBuilder.AppendParameter(request.MinAccessLevel.GetValueOrDefault());
                }

                if (request.OrderBy.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("order_by=");
                    urlBuilder.AppendParameter(request.OrderBy.GetValueOrDefault());
                }

                if (request.Sort.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("sort=");
                    urlBuilder.AppendParameter(request.Sort.GetValueOrDefault());
                }

                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/uploads</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#upload-a-file" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<RepositoryFileUploaded> Projects_UploadFileAsync(Meziantou.GitLab.UploadFileProjectRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Projects_UploadFileAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Post;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                System.Net.Http.MultipartFormDataContent content = new System.Net.Http.MultipartFormDataContent();
                if ((request.File != null))
                {
                    content.Add(request.File.ToHttpContent(), "file", request.File.FileName);
                }

                requestMessage.Content = content;
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    RepositoryFileUploaded? result = await response.ToObjectAsync<RepositoryFileUploaded>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'RepositoryFileUploaded' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Projects_UploadFileAsync_BuildUrl(Meziantou.GitLab.UploadFileProjectRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("projects/");
                if (request.Id.HasValue)
                {
                    urlBuilder.AppendParameter(request.Id.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/uploads");
                url = urlBuilder.ToString();
            }

            return url;
        }
    }

    public static partial class GitLabClientExtensions
    {
        /// <summary>
        ///   <para>URL: <c>POST /projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#create-project" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<Project> CreateAsync(this Meziantou.GitLab.IGitLabProjectsClient client, string? name = default(string?), string? path = default(string?), long? namespaceId = default(long?), string? defaultBranch = default(string?), string? description = default(string?), bool? issuesEnabled = default(bool?), bool? mergeRequestsEnabled = default(bool?), bool? jobsEnabled = default(bool?), bool? wikiEnabled = default(bool?), bool? snippetsEnabled = default(bool?), bool? resolveOutdatedDiffDiscussions = default(bool?), bool? containerRegistryEnabled = default(bool?), bool? sharedRunnersEnabled = default(bool?), bool? publicBuilds = default(bool?), bool? onlyAllowMergeIfPipelineSucceeds = default(bool?), bool? onlyAllowMergeIfAllDiscussionsAreResolved = default(bool?), bool? requestAccessEnabled = default(bool?), bool? lfsEnabled = default(bool?), bool? printingMergeRequestLinkEnabled = default(bool?), MergeMethod? mergeMethod = default(MergeMethod?), Visibility? visibility = default(Visibility?), System.Collections.Generic.IEnumerable<string>? tagList = default(System.Collections.Generic.IEnumerable<string>?), string? ciConfigPath = default(string?), int? approvalsBeforeMerge = default(int?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.CreateProjectRequest request = new Meziantou.GitLab.CreateProjectRequest();
            request.Name = name;
            request.Path = path;
            request.NamespaceId = namespaceId;
            request.DefaultBranch = defaultBranch;
            request.Description = description;
            request.IssuesEnabled = issuesEnabled;
            request.MergeRequestsEnabled = mergeRequestsEnabled;
            request.JobsEnabled = jobsEnabled;
            request.WikiEnabled = wikiEnabled;
            request.SnippetsEnabled = snippetsEnabled;
            request.ResolveOutdatedDiffDiscussions = resolveOutdatedDiffDiscussions;
            request.ContainerRegistryEnabled = containerRegistryEnabled;
            request.SharedRunnersEnabled = sharedRunnersEnabled;
            request.PublicBuilds = publicBuilds;
            request.OnlyAllowMergeIfPipelineSucceeds = onlyAllowMergeIfPipelineSucceeds;
            request.OnlyAllowMergeIfAllDiscussionsAreResolved = onlyAllowMergeIfAllDiscussionsAreResolved;
            request.RequestAccessEnabled = requestAccessEnabled;
            request.LfsEnabled = lfsEnabled;
            request.PrintingMergeRequestLinkEnabled = printingMergeRequestLinkEnabled;
            request.MergeMethod = mergeMethod;
            request.Visibility = visibility;
            request.TagList = tagList;
            request.CiConfigPath = ciConfigPath;
            request.ApprovalsBeforeMerge = approvalsBeforeMerge;
            return client.CreateAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#list-all-projects" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        public static Meziantou.GitLab.PagedResponse<Project> GetAll(this Meziantou.GitLab.IGitLabProjectsClient client, bool? archived = default(bool?), Visibility? visibility = default(Visibility?), string? search = default(string?), bool? simple = default(bool?), bool? owned = default(bool?), bool? membership = default(bool?), bool? starred = default(bool?), bool? statistics = default(bool?), bool? withIssuesEnabled = default(bool?), bool? withMergeRequestsEnabled = default(bool?), bool? wikiChecksumFailed = default(bool?), bool? repositoryChecksumFailed = default(bool?), AccessLevel? minAccessLevel = default(AccessLevel?), UsersOrderBy? orderBy = default(UsersOrderBy?), OrderByDirection? sort = default(OrderByDirection?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            Meziantou.GitLab.GetAllProjectRequest request = new Meziantou.GitLab.GetAllProjectRequest();
            request.Archived = archived;
            request.Visibility = visibility;
            request.Search = search;
            request.Simple = simple;
            request.Owned = owned;
            request.Membership = membership;
            request.Starred = starred;
            request.Statistics = statistics;
            request.WithIssuesEnabled = withIssuesEnabled;
            request.WithMergeRequestsEnabled = withMergeRequestsEnabled;
            request.WikiChecksumFailed = wikiChecksumFailed;
            request.RepositoryChecksumFailed = repositoryChecksumFailed;
            request.MinAccessLevel = minAccessLevel;
            request.OrderBy = orderBy;
            request.Sort = sort;
            return client.GetAll(request, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#get-single-project" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<Project?> GetByIdAsync(this Meziantou.GitLab.IGitLabProjectsClient client, ProjectIdOrPathRef id, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.GetByIdProjectRequest request = new Meziantou.GitLab.GetByIdProjectRequest(id);
            return client.GetByIdAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:user_id/projects</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#list-user-projects" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        public static Meziantou.GitLab.PagedResponse<Project> GetByUser(this Meziantou.GitLab.IGitLabProjectsClient client, UserIdOrUserNameRef userId, bool? archived = default(bool?), Visibility? visibility = default(Visibility?), string? search = default(string?), bool? simple = default(bool?), bool? owned = default(bool?), bool? membership = default(bool?), bool? starred = default(bool?), bool? statistics = default(bool?), bool? withIssuesEnabled = default(bool?), bool? withMergeRequestsEnabled = default(bool?), AccessLevel? minAccessLevel = default(AccessLevel?), UsersOrderBy? orderBy = default(UsersOrderBy?), OrderByDirection? sort = default(OrderByDirection?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            Meziantou.GitLab.GetByUserProjectRequest request = new Meziantou.GitLab.GetByUserProjectRequest(userId);
            request.Archived = archived;
            request.Visibility = visibility;
            request.Search = search;
            request.Simple = simple;
            request.Owned = owned;
            request.Membership = membership;
            request.Starred = starred;
            request.Statistics = statistics;
            request.WithIssuesEnabled = withIssuesEnabled;
            request.WithMergeRequestsEnabled = withMergeRequestsEnabled;
            request.MinAccessLevel = minAccessLevel;
            request.OrderBy = orderBy;
            request.Sort = sort;
            return client.GetByUser(request, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/uploads</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/projects.html#upload-a-file" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<RepositoryFileUploaded> UploadFileAsync(this Meziantou.GitLab.IGitLabProjectsClient client, ProjectIdOrPathRef id, Meziantou.GitLab.FileUpload file, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.UploadFileProjectRequest request = new Meziantou.GitLab.UploadFileProjectRequest(id, file);
            return client.UploadFileAsync(request, requestOptions, cancellationToken);
        }
    }

    public partial class GetAllProjectRequest
    {
        private bool? _archived;

        private bool? _membership;

        private AccessLevel? _minAccessLevel;

        private UsersOrderBy? _orderBy;

        private bool? _owned;

        private bool? _repositoryChecksumFailed;

        private string? _search;

        private bool? _simple;

        private OrderByDirection? _sort;

        private bool? _starred;

        private bool? _statistics;

        private Visibility? _visibility;

        private bool? _wikiChecksumFailed;

        private bool? _withIssuesEnabled;

        private bool? _withMergeRequestsEnabled;

        public GetAllProjectRequest()
        {
        }

        /// <summary>
        ///   <para>Limit by archived status.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Archived
        {
            get
            {
                return this._archived;
            }
            set
            {
                this._archived = value;
            }
        }

        /// <summary>
        ///   <para>Limit by projects that the current user is a member of.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Membership
        {
            get
            {
                return this._membership;
            }
            set
            {
                this._membership = value;
            }
        }

        /// <summary>
        ///   <para>Limit by current user minimal access level.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public AccessLevel? MinAccessLevel
        {
            get
            {
                return this._minAccessLevel;
            }
            set
            {
                this._minAccessLevel = value;
            }
        }

        /// <summary>
        ///   <para>Return projects ordered by id, name, path, created_at, updated_at, or last_activity_at fields. repository_size, storage_size, packages_size or wiki_size fields are only allowed for admins. Default is created_at.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public UsersOrderBy? OrderBy
        {
            get
            {
                return this._orderBy;
            }
            set
            {
                this._orderBy = value;
            }
        }

        /// <summary>
        ///   <para>Limit by projects explicitly owned by the current user.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Owned
        {
            get
            {
                return this._owned;
            }
            set
            {
                this._owned = value;
            }
        }

        /// <summary>
        ///   <para>Limit projects where the repository checksum calculation has failed (Introduced in GitLab Premium 11.2).</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? RepositoryChecksumFailed
        {
            get
            {
                return this._repositoryChecksumFailed;
            }
            set
            {
                this._repositoryChecksumFailed = value;
            }
        }

        /// <summary>
        ///   <para>Return list of projects matching the search criteria.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public string? Search
        {
            get
            {
                return this._search;
            }
            set
            {
                this._search = value;
            }
        }

        /// <summary>
        ///   <para>Return only limited fields for each project. This is a no-op without authentication as then only simple fields are returned.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Simple
        {
            get
            {
                return this._simple;
            }
            set
            {
                this._simple = value;
            }
        }

        /// <summary>
        ///   <para>Return projects sorted in asc or desc order. Default is desc.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public OrderByDirection? Sort
        {
            get
            {
                return this._sort;
            }
            set
            {
                this._sort = value;
            }
        }

        /// <summary>
        ///   <para>Limit by projects starred by the current user.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Starred
        {
            get
            {
                return this._starred;
            }
            set
            {
                this._starred = value;
            }
        }

        /// <summary>
        ///   <para>Include project statistics.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Statistics
        {
            get
            {
                return this._statistics;
            }
            set
            {
                this._statistics = value;
            }
        }

        /// <summary>
        ///   <para>Limit by visibility public, internal, or private.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public Visibility? Visibility
        {
            get
            {
                return this._visibility;
            }
            set
            {
                this._visibility = value;
            }
        }

        /// <summary>
        ///   <para>Limit projects where the wiki checksum calculation has failed (Introduced in GitLab Premium 11.2).</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? WikiChecksumFailed
        {
            get
            {
                return this._wikiChecksumFailed;
            }
            set
            {
                this._wikiChecksumFailed = value;
            }
        }

        /// <summary>
        ///   <para>Limit by enabled issues feature.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? WithIssuesEnabled
        {
            get
            {
                return this._withIssuesEnabled;
            }
            set
            {
                this._withIssuesEnabled = value;
            }
        }

        /// <summary>
        ///   <para>Limit by enabled merge requests feature.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? WithMergeRequestsEnabled
        {
            get
            {
                return this._withMergeRequestsEnabled;
            }
            set
            {
                this._withMergeRequestsEnabled = value;
            }
        }
    }

    public partial class GetByUserProjectRequest
    {
        private bool? _archived;

        private bool? _membership;

        private AccessLevel? _minAccessLevel;

        private UsersOrderBy? _orderBy;

        private bool? _owned;

        private string? _search;

        private bool? _simple;

        private OrderByDirection? _sort;

        private bool? _starred;

        private bool? _statistics;

        private UserIdOrUserNameRef? _userId;

        private Visibility? _visibility;

        private bool? _withIssuesEnabled;

        private bool? _withMergeRequestsEnabled;

        /// <param name="userId">The ID or username of the user.</param>
        public GetByUserProjectRequest(UserIdOrUserNameRef? userId)
        {
            this._userId = userId;
        }

        public GetByUserProjectRequest()
        {
        }

        /// <summary>
        ///   <para>Limit by archived status.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Archived
        {
            get
            {
                return this._archived;
            }
            set
            {
                this._archived = value;
            }
        }

        /// <summary>
        ///   <para>Limit by projects that the current user is a member of.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Membership
        {
            get
            {
                return this._membership;
            }
            set
            {
                this._membership = value;
            }
        }

        /// <summary>
        ///   <para>Limit by current user minimal access level.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public AccessLevel? MinAccessLevel
        {
            get
            {
                return this._minAccessLevel;
            }
            set
            {
                this._minAccessLevel = value;
            }
        }

        /// <summary>
        ///   <para>Return projects ordered by id, name, path, created_at, updated_at, or last_activity_at fields. Default is created_at.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public UsersOrderBy? OrderBy
        {
            get
            {
                return this._orderBy;
            }
            set
            {
                this._orderBy = value;
            }
        }

        /// <summary>
        ///   <para>Limit by projects explicitly owned by the current user.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Owned
        {
            get
            {
                return this._owned;
            }
            set
            {
                this._owned = value;
            }
        }

        /// <summary>
        ///   <para>Return list of projects matching the search criteria.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public string? Search
        {
            get
            {
                return this._search;
            }
            set
            {
                this._search = value;
            }
        }

        /// <summary>
        ///   <para>Return only limited fields for each project. This is a no-op without authentication as then only simple fields are returned.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Simple
        {
            get
            {
                return this._simple;
            }
            set
            {
                this._simple = value;
            }
        }

        /// <summary>
        ///   <para>Return projects sorted in asc or desc order. Default is desc.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public OrderByDirection? Sort
        {
            get
            {
                return this._sort;
            }
            set
            {
                this._sort = value;
            }
        }

        /// <summary>
        ///   <para>Limit by projects starred by the current user.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Starred
        {
            get
            {
                return this._starred;
            }
            set
            {
                this._starred = value;
            }
        }

        /// <summary>
        ///   <para>Include project statistics.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Statistics
        {
            get
            {
                return this._statistics;
            }
            set
            {
                this._statistics = value;
            }
        }

        /// <summary>
        ///   <para>The ID or username of the user.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public UserIdOrUserNameRef? UserId
        {
            get
            {
                return this._userId;
            }
            set
            {
                this._userId = value;
            }
        }

        /// <summary>
        ///   <para>Limit by visibility public, internal, or private.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public Visibility? Visibility
        {
            get
            {
                return this._visibility;
            }
            set
            {
                this._visibility = value;
            }
        }

        /// <summary>
        ///   <para>Limit by enabled issues feature.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? WithIssuesEnabled
        {
            get
            {
                return this._withIssuesEnabled;
            }
            set
            {
                this._withIssuesEnabled = value;
            }
        }

        /// <summary>
        ///   <para>Limit by enabled merge requests feature.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? WithMergeRequestsEnabled
        {
            get
            {
                return this._withMergeRequestsEnabled;
            }
            set
            {
                this._withMergeRequestsEnabled = value;
            }
        }
    }

    public partial class GetByIdProjectRequest
    {
        private ProjectIdOrPathRef? _id;

        /// <param name="id">The ID or URL-encoded path of the project.</param>
        public GetByIdProjectRequest(ProjectIdOrPathRef? id)
        {
            this._id = id;
        }

        public GetByIdProjectRequest()
        {
        }

        /// <summary>
        ///   <para>The ID or URL-encoded path of the project.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public ProjectIdOrPathRef? Id
        {
            get
            {
                return this._id;
            }
            set
            {
                this._id = value;
            }
        }
    }

    public partial class CreateProjectRequest
    {
        private int? _approvalsBeforeMerge;

        private string? _ciConfigPath;

        private bool? _containerRegistryEnabled;

        private string? _defaultBranch;

        private string? _description;

        private bool? _issuesEnabled;

        private bool? _jobsEnabled;

        private bool? _lfsEnabled;

        private MergeMethod? _mergeMethod;

        private bool? _mergeRequestsEnabled;

        private string? _name;

        private long? _namespaceId;

        private bool? _onlyAllowMergeIfAllDiscussionsAreResolved;

        private bool? _onlyAllowMergeIfPipelineSucceeds;

        private string? _path;

        private bool? _printingMergeRequestLinkEnabled;

        private bool? _publicBuilds;

        private bool? _requestAccessEnabled;

        private bool? _resolveOutdatedDiffDiscussions;

        private bool? _sharedRunnersEnabled;

        private bool? _snippetsEnabled;

        private System.Collections.Generic.IEnumerable<string>? _tagList;

        private Visibility? _visibility;

        private bool? _wikiEnabled;

        public CreateProjectRequest()
        {
        }

        /// <summary>
        ///   <para>How many approvers should approve merge requests by default.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("approvals_before_merge")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public int? ApprovalsBeforeMerge
        {
            get
            {
                return this._approvalsBeforeMerge;
            }
            set
            {
                this._approvalsBeforeMerge = value;
            }
        }

        /// <summary>
        ///   <para>The path to CI configuration file.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("ci_config_path")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public string? CiConfigPath
        {
            get
            {
                return this._ciConfigPath;
            }
            set
            {
                this._ciConfigPath = value;
            }
        }

        /// <summary>
        ///   <para>Enable container registry for this project.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("container_registry_enabled")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? ContainerRegistryEnabled
        {
            get
            {
                return this._containerRegistryEnabled;
            }
            set
            {
                this._containerRegistryEnabled = value;
            }
        }

        /// <summary>
        ///   <para>master by default.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("default_branch")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public string? DefaultBranch
        {
            get
            {
                return this._defaultBranch;
            }
            set
            {
                this._defaultBranch = value;
            }
        }

        /// <summary>
        ///   <para>Short project description.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("description")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public string? Description
        {
            get
            {
                return this._description;
            }
            set
            {
                this._description = value;
            }
        }

        /// <summary>
        ///   <para>(Deprecated) Enable issues for this project. Use issues_access_level instead.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("issues_enabled")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? IssuesEnabled
        {
            get
            {
                return this._issuesEnabled;
            }
            set
            {
                this._issuesEnabled = value;
            }
        }

        /// <summary>
        ///   <para>(Deprecated) Enable jobs for this project. Use builds_access_level instead.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("jobs_enabled")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? JobsEnabled
        {
            get
            {
                return this._jobsEnabled;
            }
            set
            {
                this._jobsEnabled = value;
            }
        }

        /// <summary>
        ///   <para>Enable LFS.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("lfs_enabled")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? LfsEnabled
        {
            get
            {
                return this._lfsEnabled;
            }
            set
            {
                this._lfsEnabled = value;
            }
        }

        /// <summary>
        ///   <para>Set the merge method used.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("merge_method")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public MergeMethod? MergeMethod
        {
            get
            {
                return this._mergeMethod;
            }
            set
            {
                this._mergeMethod = value;
            }
        }

        /// <summary>
        ///   <para>(Deprecated) Enable merge requests for this project. Use merge_requests_access_level instead.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("merge_requests_enabled")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? MergeRequestsEnabled
        {
            get
            {
                return this._mergeRequestsEnabled;
            }
            set
            {
                this._mergeRequestsEnabled = value;
            }
        }

        /// <summary>
        ///   <para>The name of the new project. Equals path if not provided.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public string? Name
        {
            get
            {
                return this._name;
            }
            set
            {
                this._name = value;
            }
        }

        /// <summary>
        ///   <para>Namespace for the new project (defaults to the current user’s namespace).</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("namespace_id")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public long? NamespaceId
        {
            get
            {
                return this._namespaceId;
            }
            set
            {
                this._namespaceId = value;
            }
        }

        /// <summary>
        ///   <para>Set whether merge requests can only be merged when all the discussions are resolved.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("only_allow_merge_if_all_discussions_are_resolved")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? OnlyAllowMergeIfAllDiscussionsAreResolved
        {
            get
            {
                return this._onlyAllowMergeIfAllDiscussionsAreResolved;
            }
            set
            {
                this._onlyAllowMergeIfAllDiscussionsAreResolved = value;
            }
        }

        /// <summary>
        ///   <para>Set whether merge requests can only be merged with successful jobs.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("only_allow_merge_if_pipeline_succeeds")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? OnlyAllowMergeIfPipelineSucceeds
        {
            get
            {
                return this._onlyAllowMergeIfPipelineSucceeds;
            }
            set
            {
                this._onlyAllowMergeIfPipelineSucceeds = value;
            }
        }

        /// <summary>
        ///   <para>Repository name for new project. Generated based on name if not provided (generated as lowercase with dashes).</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("path")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public string? Path
        {
            get
            {
                return this._path;
            }
            set
            {
                this._path = value;
            }
        }

        /// <summary>
        ///   <para>Show link to create/view merge request when pushing from the command line.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("printing_merge_request_link_enabled")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? PrintingMergeRequestLinkEnabled
        {
            get
            {
                return this._printingMergeRequestLinkEnabled;
            }
            set
            {
                this._printingMergeRequestLinkEnabled = value;
            }
        }

        /// <summary>
        ///   <para>If true, jobs can be viewed by non-project members.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("public_builds")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? PublicBuilds
        {
            get
            {
                return this._publicBuilds;
            }
            set
            {
                this._publicBuilds = value;
            }
        }

        /// <summary>
        ///   <para>Allow users to request member access.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("request_access_enabled")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? RequestAccessEnabled
        {
            get
            {
                return this._requestAccessEnabled;
            }
            set
            {
                this._requestAccessEnabled = value;
            }
        }

        /// <summary>
        ///   <para>Automatically resolve merge request diffs discussions on lines changed with a push.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("resolve_outdated_diff_discussions")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? ResolveOutdatedDiffDiscussions
        {
            get
            {
                return this._resolveOutdatedDiffDiscussions;
            }
            set
            {
                this._resolveOutdatedDiffDiscussions = value;
            }
        }

        /// <summary>
        ///   <para>Enable shared runners for this project.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("shared_runners_enabled")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? SharedRunnersEnabled
        {
            get
            {
                return this._sharedRunnersEnabled;
            }
            set
            {
                this._sharedRunnersEnabled = value;
            }
        }

        /// <summary>
        ///   <para>(Deprecated) Enable snippets for this project. Use snippets_access_level instead.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("snippets_enabled")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? SnippetsEnabled
        {
            get
            {
                return this._snippetsEnabled;
            }
            set
            {
                this._snippetsEnabled = value;
            }
        }

        /// <summary>
        ///   <para>The list of tags for a project; put array of tags, that should be finally assigned to a project.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("tag_list")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public System.Collections.Generic.IEnumerable<string>? TagList
        {
            get
            {
                return this._tagList;
            }
            set
            {
                this._tagList = value;
            }
        }

        /// <summary>
        ///   <para>See project visibility level.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("visibility")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public Visibility? Visibility
        {
            get
            {
                return this._visibility;
            }
            set
            {
                this._visibility = value;
            }
        }

        /// <summary>
        ///   <para>(Deprecated) Enable wiki for this project. Use wiki_access_level instead.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("wiki_enabled")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? WikiEnabled
        {
            get
            {
                return this._wikiEnabled;
            }
            set
            {
                this._wikiEnabled = value;
            }
        }
    }

    public partial class UploadFileProjectRequest
    {
        private Meziantou.GitLab.FileUpload? _file;

        private ProjectIdOrPathRef? _id;

        /// <param name="id">The ID or URL-encoded path of the project.</param>
        /// <param name="file">The file to be uploaded.</param>
        public UploadFileProjectRequest(ProjectIdOrPathRef? id, Meziantou.GitLab.FileUpload? file)
        {
            this._id = id;
            this._file = file;
        }

        public UploadFileProjectRequest()
        {
        }

        /// <summary>
        ///   <para>The file to be uploaded.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("file")]
        public Meziantou.GitLab.FileUpload? File
        {
            get
            {
                return this._file;
            }
            set
            {
                this._file = value;
            }
        }

        /// <summary>
        ///   <para>The ID or URL-encoded path of the project.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public ProjectIdOrPathRef? Id
        {
            get
            {
                return this._id;
            }
            set
            {
                this._id = value;
            }
        }
    }
}
