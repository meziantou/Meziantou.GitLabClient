// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated
// </auto-generated>
// ------------------------------------------------------------------------------
#nullable enable
namespace Meziantou.GitLab
{
    public partial interface IGitLabClient
    {
        Meziantou.GitLab.IGitLabUsersClient Users
        {
            get;
        }
    }

    public partial interface IGitLabUsersClient
    {
        /// <summary>
        ///   <para>URL: <c>POST /users/:id_or_username/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#add-ssh-key-for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<SshKey> AddSSHKeyAsync(Meziantou.GitLab.AddSSHKeyUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>POST /user/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#add-ssh-key" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<SshKey> AddSSHKeyToCurrentUserAsync(Meziantou.GitLab.AddSSHKeyToCurrentUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>POST /users/:user_id/impersonation_tokens</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#create-an-impersonation-token" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<ImpersonationToken> CreateImpersonationTokenAsync(Meziantou.GitLab.CreateImpersonationTokenUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>POST /users</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#user-creation" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<User> CreateUserAsync(Meziantou.GitLab.CreateUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>DELETE /users/:id_or_username/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#delete-ssh-key-for-given-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task DeleteSSHKeyAsync(Meziantou.GitLab.DeleteSSHKeyUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>DELETE /user/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#delete-ssh-key-for-current-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task DeleteSSHKeyFromCurrentUserAsync(Meziantou.GitLab.DeleteSSHKeyFromCurrentUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>GET /users</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#for-normal-users" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<UserBasic> GetAll(Meziantou.GitLab.GetAllUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions));

        /// <summary>
        ///   <para>URL: <c>GET /users/:user_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<User?> GetByIdAsync(Meziantou.GitLab.GetByIdUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>GET /user</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-current-user-for-normal-users" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<User?> GetCurrentUserAsync(Meziantou.GitLab.GetCurrentUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>GET /user/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#single-ssh-key" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<SshKey?> GetCurrentUserSSHKeyAsync(Meziantou.GitLab.GetCurrentUserSSHKeyRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>GET /user/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-ssh-keys" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<SshKey>> GetCurrentUserSSHKeysAsync(Meziantou.GitLab.GetCurrentUserSSHKeysRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>GET /user/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#user-status" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<UserStatus?> GetCurrentUserStatusAsync(Meziantou.GitLab.GetCurrentUserStatusRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>GET /users/:id_or_username/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-ssh-keys-for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<SshKey>> GetSSHKeysAsync(Meziantou.GitLab.GetSSHKeysUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>GET /users/:id_or_username/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#get-the-status-of-a-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<UserStatus?> GetStatusAsync(Meziantou.GitLab.GetStatusUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>PUT /user/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#set-user-status" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<UserStatus> SetCurrentUserStatusAsync(Meziantou.GitLab.SetCurrentUserStatusRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
    }

    public partial class GitLabClient : Meziantou.GitLab.IGitLabUsersClient
    {
        /// <summary>
        ///   <para>URL: <c>POST /users/:id_or_username/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#add-ssh-key-for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<SshKey> Meziantou.GitLab.IGitLabUsersClient.AddSSHKeyAsync(Meziantou.GitLab.AddSSHKeyUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_AddSSHKeyAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>POST /user/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#add-ssh-key" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<SshKey> Meziantou.GitLab.IGitLabUsersClient.AddSSHKeyToCurrentUserAsync(Meziantou.GitLab.AddSSHKeyToCurrentUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_AddSSHKeyToCurrentUserAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>POST /users/:user_id/impersonation_tokens</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#create-an-impersonation-token" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<ImpersonationToken> Meziantou.GitLab.IGitLabUsersClient.CreateImpersonationTokenAsync(Meziantou.GitLab.CreateImpersonationTokenUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_CreateImpersonationTokenAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>POST /users</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#user-creation" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<User> Meziantou.GitLab.IGitLabUsersClient.CreateUserAsync(Meziantou.GitLab.CreateUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_CreateUserAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>DELETE /users/:id_or_username/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#delete-ssh-key-for-given-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task Meziantou.GitLab.IGitLabUsersClient.DeleteSSHKeyAsync(Meziantou.GitLab.DeleteSSHKeyUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_DeleteSSHKeyAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>DELETE /user/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#delete-ssh-key-for-current-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task Meziantou.GitLab.IGitLabUsersClient.DeleteSSHKeyFromCurrentUserAsync(Meziantou.GitLab.DeleteSSHKeyFromCurrentUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_DeleteSSHKeyFromCurrentUserAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /users</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#for-normal-users" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<UserBasic> Meziantou.GitLab.IGitLabUsersClient.GetAll(Meziantou.GitLab.GetAllUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions)
        {
            return this.Users_GetAll(request, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:user_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<User?> Meziantou.GitLab.IGitLabUsersClient.GetByIdAsync(Meziantou.GitLab.GetByIdUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_GetByIdAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /user</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-current-user-for-normal-users" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<User?> Meziantou.GitLab.IGitLabUsersClient.GetCurrentUserAsync(Meziantou.GitLab.GetCurrentUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_GetCurrentUserAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /user/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#single-ssh-key" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<SshKey?> Meziantou.GitLab.IGitLabUsersClient.GetCurrentUserSSHKeyAsync(Meziantou.GitLab.GetCurrentUserSSHKeyRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_GetCurrentUserSSHKeyAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /user/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-ssh-keys" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<SshKey>> Meziantou.GitLab.IGitLabUsersClient.GetCurrentUserSSHKeysAsync(Meziantou.GitLab.GetCurrentUserSSHKeysRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_GetCurrentUserSSHKeysAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /user/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#user-status" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<UserStatus?> Meziantou.GitLab.IGitLabUsersClient.GetCurrentUserStatusAsync(Meziantou.GitLab.GetCurrentUserStatusRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_GetCurrentUserStatusAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:id_or_username/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-ssh-keys-for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<SshKey>> Meziantou.GitLab.IGitLabUsersClient.GetSSHKeysAsync(Meziantou.GitLab.GetSSHKeysUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_GetSSHKeysAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:id_or_username/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#get-the-status-of-a-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<UserStatus?> Meziantou.GitLab.IGitLabUsersClient.GetStatusAsync(Meziantou.GitLab.GetStatusUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_GetStatusAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>PUT /user/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#set-user-status" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<UserStatus> Meziantou.GitLab.IGitLabUsersClient.SetCurrentUserStatusAsync(Meziantou.GitLab.SetCurrentUserStatusRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Users_SetCurrentUserStatusAsync(request, requestOptions, cancellationToken);
        }

        public Meziantou.GitLab.IGitLabUsersClient Users
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        ///   <para>URL: <c>POST /users/:id_or_username/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#add-ssh-key-for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<SshKey> Users_AddSSHKeyAsync(Meziantou.GitLab.AddSSHKeyUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_AddSSHKeyAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Post;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                requestMessage.Content = new Meziantou.GitLab.Internals.JsonContent(request, Meziantou.GitLab.Serialization.JsonSerialization.Options);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    SshKey? result = await response.ToObjectAsync<SshKey>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'SshKey' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Users_AddSSHKeyAsync_BuildUrl(Meziantou.GitLab.AddSSHKeyUserRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("users/");
                if (request.IdOrUsername.HasValue)
                {
                    urlBuilder.AppendParameter(request.IdOrUsername.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/keys");
                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>POST /user/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#add-ssh-key" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<SshKey> Users_AddSSHKeyToCurrentUserAsync(Meziantou.GitLab.AddSSHKeyToCurrentUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_AddSSHKeyToCurrentUserAsync_BuildUrl();
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Post;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                requestMessage.Content = new Meziantou.GitLab.Internals.JsonContent(request, Meziantou.GitLab.Serialization.JsonSerialization.Options);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    SshKey? result = await response.ToObjectAsync<SshKey>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'SshKey' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        private static string Users_AddSSHKeyToCurrentUserAsync_BuildUrl()
        {
            string url;
            url = "user/keys";
            return url;
        }

        /// <summary>
        ///   <para>URL: <c>POST /users/:user_id/impersonation_tokens</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#create-an-impersonation-token" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<ImpersonationToken> Users_CreateImpersonationTokenAsync(Meziantou.GitLab.CreateImpersonationTokenUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_CreateImpersonationTokenAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Post;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                requestMessage.Content = new Meziantou.GitLab.Internals.JsonContent(request, Meziantou.GitLab.Serialization.JsonSerialization.Options);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    ImpersonationToken? result = await response.ToObjectAsync<ImpersonationToken>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'ImpersonationToken' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Users_CreateImpersonationTokenAsync_BuildUrl(Meziantou.GitLab.CreateImpersonationTokenUserRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("users/");
                if (request.UserId.HasValue)
                {
                    urlBuilder.AppendParameter(request.UserId.GetValueOrDefault().Value);
                }

                urlBuilder.Append("/impersonation_tokens");
                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>POST /users</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#user-creation" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<User> Users_CreateUserAsync(Meziantou.GitLab.CreateUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_CreateUserAsync_BuildUrl();
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Post;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                requestMessage.Content = new Meziantou.GitLab.Internals.JsonContent(request, Meziantou.GitLab.Serialization.JsonSerialization.Options);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    User? result = await response.ToObjectAsync<User>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'User' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        private static string Users_CreateUserAsync_BuildUrl()
        {
            string url;
            url = "users";
            return url;
        }

        /// <summary>
        ///   <para>URL: <c>DELETE /users/:id_or_username/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#delete-ssh-key-for-given-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task Users_DeleteSSHKeyAsync(Meziantou.GitLab.DeleteSSHKeyUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_DeleteSSHKeyAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Delete;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Users_DeleteSSHKeyAsync_BuildUrl(Meziantou.GitLab.DeleteSSHKeyUserRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("users/");
                if (request.IdOrUsername.HasValue)
                {
                    urlBuilder.AppendParameter(request.IdOrUsername.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/keys/");
                if (request.KeyId.HasValue)
                {
                    urlBuilder.AppendParameter(request.KeyId.GetValueOrDefault().Value);
                }

                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>DELETE /user/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#delete-ssh-key-for-current-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task Users_DeleteSSHKeyFromCurrentUserAsync(Meziantou.GitLab.DeleteSSHKeyFromCurrentUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_DeleteSSHKeyFromCurrentUserAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Delete;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Users_DeleteSSHKeyFromCurrentUserAsync_BuildUrl(Meziantou.GitLab.DeleteSSHKeyFromCurrentUserRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("user/keys/");
                if (request.KeyId.HasValue)
                {
                    urlBuilder.AppendParameter(request.KeyId.GetValueOrDefault().Value);
                }

                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>GET /users</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#for-normal-users" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        private Meziantou.GitLab.PagedResponse<UserBasic> Users_GetAll(Meziantou.GitLab.GetAllUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_GetAll_BuildUrl(request);
            return new Meziantou.GitLab.PagedResponse<UserBasic>(this, url, requestOptions);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Users_GetAll_BuildUrl(Meziantou.GitLab.GetAllUserRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("users");
                char separator = '?';
                if ((!object.ReferenceEquals(request.Username, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("username=");
                    urlBuilder.AppendParameter(request.Username);
                }

                if (request.Active.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("active=");
                    urlBuilder.AppendParameter(request.Active.GetValueOrDefault());
                }

                if (request.Blocked.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("blocked=");
                    urlBuilder.AppendParameter(request.Blocked.GetValueOrDefault());
                }

                if (request.OrderBy.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("order_by=");
                    urlBuilder.AppendParameter(request.OrderBy.GetValueOrDefault());
                }

                if (request.Sort.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("sort=");
                    urlBuilder.AppendParameter(request.Sort.GetValueOrDefault());
                }

                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:user_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<User?> Users_GetByIdAsync(Meziantou.GitLab.GetByIdUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_GetByIdAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Get;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    if ((response.StatusCode == System.Net.HttpStatusCode.NotFound))
                    {
                        return default;
                    }

                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    User? result = await response.ToObjectAsync<User>(cancellationToken).ConfigureAwait(false);
                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Users_GetByIdAsync_BuildUrl(Meziantou.GitLab.GetByIdUserRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("users/");
                if (request.UserId.HasValue)
                {
                    urlBuilder.AppendParameter(request.UserId.GetValueOrDefault().Value);
                }

                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>GET /user</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-current-user-for-normal-users" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<User?> Users_GetCurrentUserAsync(Meziantou.GitLab.GetCurrentUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_GetCurrentUserAsync_BuildUrl();
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Get;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    if ((response.StatusCode == System.Net.HttpStatusCode.NotFound))
                    {
                        return default;
                    }

                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    User? result = await response.ToObjectAsync<User>(cancellationToken).ConfigureAwait(false);
                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        private static string Users_GetCurrentUserAsync_BuildUrl()
        {
            string url;
            url = "user";
            return url;
        }

        /// <summary>
        ///   <para>URL: <c>GET /user/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#single-ssh-key" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<SshKey?> Users_GetCurrentUserSSHKeyAsync(Meziantou.GitLab.GetCurrentUserSSHKeyRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_GetCurrentUserSSHKeyAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Get;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    if ((response.StatusCode == System.Net.HttpStatusCode.NotFound))
                    {
                        return default;
                    }

                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    SshKey? result = await response.ToObjectAsync<SshKey>(cancellationToken).ConfigureAwait(false);
                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Users_GetCurrentUserSSHKeyAsync_BuildUrl(Meziantou.GitLab.GetCurrentUserSSHKeyRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("user/keys/");
                if (request.KeyId.HasValue)
                {
                    urlBuilder.AppendParameter(request.KeyId.GetValueOrDefault().Value);
                }

                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>GET /user/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-ssh-keys" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<SshKey>> Users_GetCurrentUserSSHKeysAsync(Meziantou.GitLab.GetCurrentUserSSHKeysRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_GetCurrentUserSSHKeysAsync_BuildUrl();
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Get;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    System.Collections.Generic.IReadOnlyList<SshKey>? result = await response.ToCollectionAsync<SshKey>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'SshKey' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        private static string Users_GetCurrentUserSSHKeysAsync_BuildUrl()
        {
            string url;
            url = "user/keys";
            return url;
        }

        /// <summary>
        ///   <para>URL: <c>GET /user/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#user-status" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<UserStatus?> Users_GetCurrentUserStatusAsync(Meziantou.GitLab.GetCurrentUserStatusRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_GetCurrentUserStatusAsync_BuildUrl();
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Get;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    if ((response.StatusCode == System.Net.HttpStatusCode.NotFound))
                    {
                        return default;
                    }

                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    UserStatus? result = await response.ToObjectAsync<UserStatus>(cancellationToken).ConfigureAwait(false);
                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        private static string Users_GetCurrentUserStatusAsync_BuildUrl()
        {
            string url;
            url = "user/status";
            return url;
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:id_or_username/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-ssh-keys-for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<SshKey>> Users_GetSSHKeysAsync(Meziantou.GitLab.GetSSHKeysUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_GetSSHKeysAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Get;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    System.Collections.Generic.IReadOnlyList<SshKey>? result = await response.ToCollectionAsync<SshKey>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'SshKey' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Users_GetSSHKeysAsync_BuildUrl(Meziantou.GitLab.GetSSHKeysUserRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("users/");
                if (request.IdOrUsername.HasValue)
                {
                    urlBuilder.AppendParameter(request.IdOrUsername.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/keys");
                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:id_or_username/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#get-the-status-of-a-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<UserStatus?> Users_GetStatusAsync(Meziantou.GitLab.GetStatusUserRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_GetStatusAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Get;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    if ((response.StatusCode == System.Net.HttpStatusCode.NotFound))
                    {
                        return default;
                    }

                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    UserStatus? result = await response.ToObjectAsync<UserStatus>(cancellationToken).ConfigureAwait(false);
                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string Users_GetStatusAsync_BuildUrl(Meziantou.GitLab.GetStatusUserRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("users/");
                if (request.IdOrUsername.HasValue)
                {
                    urlBuilder.AppendParameter(request.IdOrUsername.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/status");
                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>PUT /user/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#set-user-status" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<UserStatus> Users_SetCurrentUserStatusAsync(Meziantou.GitLab.SetCurrentUserStatusRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Users_SetCurrentUserStatusAsync_BuildUrl();
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Put;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                requestMessage.Content = new Meziantou.GitLab.Internals.JsonContent(request, Meziantou.GitLab.Serialization.JsonSerialization.Options);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    UserStatus? result = await response.ToObjectAsync<UserStatus>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'UserStatus' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        private static string Users_SetCurrentUserStatusAsync_BuildUrl()
        {
            string url;
            url = "user/status";
            return url;
        }
    }

    public static partial class GitLabClientExtensions
    {
        /// <summary>
        ///   <para>URL: <c>POST /users/:id_or_username/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#add-ssh-key-for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<SshKey> AddSSHKeyAsync(this Meziantou.GitLab.IGitLabUsersClient client, UserIdOrUserNameRef idOrUsername, string title, string key, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.AddSSHKeyUserRequest request = new Meziantou.GitLab.AddSSHKeyUserRequest(idOrUsername, title, key);
            return client.AddSSHKeyAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>POST /user/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#add-ssh-key" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<SshKey> AddSSHKeyToCurrentUserAsync(this Meziantou.GitLab.IGitLabUsersClient client, string title, string key, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.AddSSHKeyToCurrentUserRequest request = new Meziantou.GitLab.AddSSHKeyToCurrentUserRequest(title, key);
            return client.AddSSHKeyToCurrentUserAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>POST /users/:user_id/impersonation_tokens</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#create-an-impersonation-token" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<ImpersonationToken> CreateImpersonationTokenAsync(this Meziantou.GitLab.IGitLabUsersClient client, UserIdRef userId, string name, System.DateTime? expiresAt = default(System.DateTime?), System.Collections.Generic.IEnumerable<ImpersonationTokenScope>? scopes = default(System.Collections.Generic.IEnumerable<ImpersonationTokenScope>?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.CreateImpersonationTokenUserRequest request = new Meziantou.GitLab.CreateImpersonationTokenUserRequest(userId, name);
            request.ExpiresAt = expiresAt;
            request.Scopes = scopes;
            return client.CreateImpersonationTokenAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>POST /users</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#user-creation" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<User> CreateUserAsync(this Meziantou.GitLab.IGitLabUsersClient client, string email, string username, string name, string? password = default(string?), bool? admin = default(bool?), bool? canCreateGroup = default(bool?), bool? skipConfirmation = default(bool?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.CreateUserRequest request = new Meziantou.GitLab.CreateUserRequest(email, username, name);
            request.Password = password;
            request.Admin = admin;
            request.CanCreateGroup = canCreateGroup;
            request.SkipConfirmation = skipConfirmation;
            return client.CreateUserAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>DELETE /users/:id_or_username/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#delete-ssh-key-for-given-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task DeleteSSHKeyAsync(this Meziantou.GitLab.IGitLabUsersClient client, UserIdOrUserNameRef idOrUsername, SshKeyIdRef keyId, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.DeleteSSHKeyUserRequest request = new Meziantou.GitLab.DeleteSSHKeyUserRequest(idOrUsername, keyId);
            return client.DeleteSSHKeyAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>DELETE /user/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#delete-ssh-key-for-current-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task DeleteSSHKeyFromCurrentUserAsync(this Meziantou.GitLab.IGitLabUsersClient client, SshKeyIdRef keyId, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.DeleteSSHKeyFromCurrentUserRequest request = new Meziantou.GitLab.DeleteSSHKeyFromCurrentUserRequest(keyId);
            return client.DeleteSSHKeyFromCurrentUserAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /users</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#for-normal-users" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        public static Meziantou.GitLab.PagedResponse<UserBasic> GetAll(this Meziantou.GitLab.IGitLabUsersClient client, string? username = default(string?), bool? active = default(bool?), bool? blocked = default(bool?), UsersOrderBy? orderBy = default(UsersOrderBy?), OrderByDirection? sort = default(OrderByDirection?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            Meziantou.GitLab.GetAllUserRequest request = new Meziantou.GitLab.GetAllUserRequest();
            request.Username = username;
            request.Active = active;
            request.Blocked = blocked;
            request.OrderBy = orderBy;
            request.Sort = sort;
            return client.GetAll(request, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:user_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<User?> GetByIdAsync(this Meziantou.GitLab.IGitLabUsersClient client, UserIdRef userId, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.GetByIdUserRequest request = new Meziantou.GitLab.GetByIdUserRequest(userId);
            return client.GetByIdAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /user</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-current-user-for-normal-users" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<User?> GetCurrentUserAsync(this Meziantou.GitLab.IGitLabUsersClient client, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.GetCurrentUserRequest request = new Meziantou.GitLab.GetCurrentUserRequest();
            return client.GetCurrentUserAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /user/keys/:key_id</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#single-ssh-key" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<SshKey?> GetCurrentUserSSHKeyAsync(this Meziantou.GitLab.IGitLabUsersClient client, SshKeyIdRef keyId, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.GetCurrentUserSSHKeyRequest request = new Meziantou.GitLab.GetCurrentUserSSHKeyRequest(keyId);
            return client.GetCurrentUserSSHKeyAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /user/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-ssh-keys" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<SshKey>> GetCurrentUserSSHKeysAsync(this Meziantou.GitLab.IGitLabUsersClient client, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.GetCurrentUserSSHKeysRequest request = new Meziantou.GitLab.GetCurrentUserSSHKeysRequest();
            return client.GetCurrentUserSSHKeysAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /user/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#user-status" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<UserStatus?> GetCurrentUserStatusAsync(this Meziantou.GitLab.IGitLabUsersClient client, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.GetCurrentUserStatusRequest request = new Meziantou.GitLab.GetCurrentUserStatusRequest();
            return client.GetCurrentUserStatusAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:id_or_username/keys</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#list-ssh-keys-for-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<SshKey>> GetSSHKeysAsync(this Meziantou.GitLab.IGitLabUsersClient client, UserIdOrUserNameRef idOrUsername, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.GetSSHKeysUserRequest request = new Meziantou.GitLab.GetSSHKeysUserRequest(idOrUsername);
            return client.GetSSHKeysAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /users/:id_or_username/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#get-the-status-of-a-user" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<UserStatus?> GetStatusAsync(this Meziantou.GitLab.IGitLabUsersClient client, UserIdOrUserNameRef idOrUsername, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.GetStatusUserRequest request = new Meziantou.GitLab.GetStatusUserRequest(idOrUsername);
            return client.GetStatusAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>PUT /user/status</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/users.html#set-user-status" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<UserStatus> SetCurrentUserStatusAsync(this Meziantou.GitLab.IGitLabUsersClient client, string? emoji = default(string?), string? message = default(string?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.SetCurrentUserStatusRequest request = new Meziantou.GitLab.SetCurrentUserStatusRequest();
            request.Emoji = emoji;
            request.Message = message;
            return client.SetCurrentUserStatusAsync(request, requestOptions, cancellationToken);
        }
    }

    public partial class GetCurrentUserRequest
    {
        public GetCurrentUserRequest()
        {
        }
    }

    public partial class GetByIdUserRequest
    {
        private UserIdRef? _userId;

        public GetByIdUserRequest(UserIdRef? userId)
        {
            this._userId = userId;
        }

        public GetByIdUserRequest()
        {
        }

        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public UserIdRef? UserId
        {
            get
            {
                return this._userId;
            }
            set
            {
                this._userId = value;
            }
        }
    }

    public partial class GetAllUserRequest
    {
        private bool? _active;

        private bool? _blocked;

        private UsersOrderBy? _orderBy;

        private OrderByDirection? _sort;

        private string? _username;

        public GetAllUserRequest()
        {
        }

        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Active
        {
            get
            {
                return this._active;
            }
            set
            {
                this._active = value;
            }
        }

        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public bool? Blocked
        {
            get
            {
                return this._blocked;
            }
            set
            {
                this._blocked = value;
            }
        }

        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public UsersOrderBy? OrderBy
        {
            get
            {
                return this._orderBy;
            }
            set
            {
                this._orderBy = value;
            }
        }

        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public OrderByDirection? Sort
        {
            get
            {
                return this._sort;
            }
            set
            {
                this._sort = value;
            }
        }

        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public string? Username
        {
            get
            {
                return this._username;
            }
            set
            {
                this._username = value;
            }
        }
    }

    public partial class GetCurrentUserStatusRequest
    {
        public GetCurrentUserStatusRequest()
        {
        }
    }

    public partial class GetStatusUserRequest
    {
        private UserIdOrUserNameRef? _idOrUsername;

        /// <param name="idOrUsername">The ID or username of the user to get a status of</param>
        public GetStatusUserRequest(UserIdOrUserNameRef? idOrUsername)
        {
            this._idOrUsername = idOrUsername;
        }

        public GetStatusUserRequest()
        {
        }

        /// <summary>
        ///   <para>The ID or username of the user to get a status of</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public UserIdOrUserNameRef? IdOrUsername
        {
            get
            {
                return this._idOrUsername;
            }
            set
            {
                this._idOrUsername = value;
            }
        }
    }

    public partial class SetCurrentUserStatusRequest
    {
        private string? _emoji;

        private string? _message;

        public SetCurrentUserStatusRequest()
        {
        }

        /// <summary>
        ///   <para>The name of the emoji to use as status. If omitted speech_balloon is used. Emoji name can be one of the specified names in the Gemojione index.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("emoji")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public string? Emoji
        {
            get
            {
                return this._emoji;
            }
            set
            {
                this._emoji = value;
            }
        }

        /// <summary>
        ///   <para>The message to set as a status. It can also contain emoji codes.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("message")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public string? Message
        {
            get
            {
                return this._message;
            }
            set
            {
                this._message = value;
            }
        }
    }

    public partial class GetCurrentUserSSHKeysRequest
    {
        public GetCurrentUserSSHKeysRequest()
        {
        }
    }

    public partial class GetSSHKeysUserRequest
    {
        private UserIdOrUserNameRef? _idOrUsername;

        /// <param name="idOrUsername">The ID or username of the user to get the SSH keys for.</param>
        public GetSSHKeysUserRequest(UserIdOrUserNameRef? idOrUsername)
        {
            this._idOrUsername = idOrUsername;
        }

        public GetSSHKeysUserRequest()
        {
        }

        /// <summary>
        ///   <para>The ID or username of the user to get the SSH keys for.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public UserIdOrUserNameRef? IdOrUsername
        {
            get
            {
                return this._idOrUsername;
            }
            set
            {
                this._idOrUsername = value;
            }
        }
    }

    public partial class GetCurrentUserSSHKeyRequest
    {
        private SshKeyIdRef? _keyId;

        public GetCurrentUserSSHKeyRequest(SshKeyIdRef? keyId)
        {
            this._keyId = keyId;
        }

        public GetCurrentUserSSHKeyRequest()
        {
        }

        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public SshKeyIdRef? KeyId
        {
            get
            {
                return this._keyId;
            }
            set
            {
                this._keyId = value;
            }
        }
    }

    public partial class AddSSHKeyToCurrentUserRequest
    {
        private string? _key;

        private string? _title;

        public AddSSHKeyToCurrentUserRequest(string? title, string? key)
        {
            this._title = title;
            this._key = key;
        }

        public AddSSHKeyToCurrentUserRequest()
        {
        }

        [System.Text.Json.Serialization.JsonPropertyNameAttribute("key")]
        public string? Key
        {
            get
            {
                return this._key;
            }
            set
            {
                this._key = value;
            }
        }

        [System.Text.Json.Serialization.JsonPropertyNameAttribute("title")]
        public string? Title
        {
            get
            {
                return this._title;
            }
            set
            {
                this._title = value;
            }
        }
    }

    public partial class AddSSHKeyUserRequest
    {
        private UserIdOrUserNameRef? _idOrUsername;

        private string? _key;

        private string? _title;

        public AddSSHKeyUserRequest(UserIdOrUserNameRef? idOrUsername, string? title, string? key)
        {
            this._idOrUsername = idOrUsername;
            this._title = title;
            this._key = key;
        }

        public AddSSHKeyUserRequest()
        {
        }

        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public UserIdOrUserNameRef? IdOrUsername
        {
            get
            {
                return this._idOrUsername;
            }
            set
            {
                this._idOrUsername = value;
            }
        }

        [System.Text.Json.Serialization.JsonPropertyNameAttribute("key")]
        public string? Key
        {
            get
            {
                return this._key;
            }
            set
            {
                this._key = value;
            }
        }

        [System.Text.Json.Serialization.JsonPropertyNameAttribute("title")]
        public string? Title
        {
            get
            {
                return this._title;
            }
            set
            {
                this._title = value;
            }
        }
    }

    public partial class DeleteSSHKeyFromCurrentUserRequest
    {
        private SshKeyIdRef? _keyId;

        public DeleteSSHKeyFromCurrentUserRequest(SshKeyIdRef? keyId)
        {
            this._keyId = keyId;
        }

        public DeleteSSHKeyFromCurrentUserRequest()
        {
        }

        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public SshKeyIdRef? KeyId
        {
            get
            {
                return this._keyId;
            }
            set
            {
                this._keyId = value;
            }
        }
    }

    public partial class DeleteSSHKeyUserRequest
    {
        private UserIdOrUserNameRef? _idOrUsername;

        private SshKeyIdRef? _keyId;

        public DeleteSSHKeyUserRequest(UserIdOrUserNameRef? idOrUsername, SshKeyIdRef? keyId)
        {
            this._idOrUsername = idOrUsername;
            this._keyId = keyId;
        }

        public DeleteSSHKeyUserRequest()
        {
        }

        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public UserIdOrUserNameRef? IdOrUsername
        {
            get
            {
                return this._idOrUsername;
            }
            set
            {
                this._idOrUsername = value;
            }
        }

        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public SshKeyIdRef? KeyId
        {
            get
            {
                return this._keyId;
            }
            set
            {
                this._keyId = value;
            }
        }
    }

    public partial class CreateUserRequest
    {
        private bool? _admin;

        private bool? _canCreateGroup;

        private string? _email;

        private string? _name;

        private string? _password;

        private bool? _skipConfirmation;

        private string? _username;

        public CreateUserRequest(string? email, string? username, string? name)
        {
            this._email = email;
            this._username = username;
            this._name = name;
        }

        public CreateUserRequest()
        {
        }

        [System.Text.Json.Serialization.JsonPropertyNameAttribute("admin")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? Admin
        {
            get
            {
                return this._admin;
            }
            set
            {
                this._admin = value;
            }
        }

        [System.Text.Json.Serialization.JsonPropertyNameAttribute("can_create_group")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? CanCreateGroup
        {
            get
            {
                return this._canCreateGroup;
            }
            set
            {
                this._canCreateGroup = value;
            }
        }

        [System.Text.Json.Serialization.JsonPropertyNameAttribute("email")]
        public string? Email
        {
            get
            {
                return this._email;
            }
            set
            {
                this._email = value;
            }
        }

        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        public string? Name
        {
            get
            {
                return this._name;
            }
            set
            {
                this._name = value;
            }
        }

        [System.Text.Json.Serialization.JsonPropertyNameAttribute("password")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public string? Password
        {
            get
            {
                return this._password;
            }
            set
            {
                this._password = value;
            }
        }

        [System.Text.Json.Serialization.JsonPropertyNameAttribute("skip_confirmation")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? SkipConfirmation
        {
            get
            {
                return this._skipConfirmation;
            }
            set
            {
                this._skipConfirmation = value;
            }
        }

        [System.Text.Json.Serialization.JsonPropertyNameAttribute("username")]
        public string? Username
        {
            get
            {
                return this._username;
            }
            set
            {
                this._username = value;
            }
        }
    }

    public partial class CreateImpersonationTokenUserRequest
    {
        private System.DateTime? _expiresAt;

        private string? _name;

        private System.Collections.Generic.IEnumerable<ImpersonationTokenScope>? _scopes;

        private UserIdRef? _userId;

        /// <param name="userId">The ID of the user</param>
        /// <param name="name">The name of the impersonation token</param>
        public CreateImpersonationTokenUserRequest(UserIdRef? userId, string? name)
        {
            this._userId = userId;
            this._name = name;
        }

        public CreateImpersonationTokenUserRequest()
        {
        }

        /// <summary>
        ///   <para>The expiration date of the impersonation token in ISO format (YYYY-MM-DD)</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("expires_at")]
        [System.Text.Json.Serialization.JsonConverterAttribute(typeof(Meziantou.GitLab.Serialization.GitLabDateJsonConverter))]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public System.DateTime? ExpiresAt
        {
            get
            {
                return this._expiresAt;
            }
            set
            {
                this._expiresAt = value;
            }
        }

        /// <summary>
        ///   <para>The name of the impersonation token</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("name")]
        public string? Name
        {
            get
            {
                return this._name;
            }
            set
            {
                this._name = value;
            }
        }

        /// <summary>
        ///   <para>The array of scopes of the impersonation token (api, read_user)</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("scopes")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public System.Collections.Generic.IEnumerable<ImpersonationTokenScope>? Scopes
        {
            get
            {
                return this._scopes;
            }
            set
            {
                this._scopes = value;
            }
        }

        /// <summary>
        ///   <para>The ID of the user</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnoreAttribute]
        public UserIdRef? UserId
        {
            get
            {
                return this._userId;
            }
            set
            {
                this._userId = value;
            }
        }
    }
}
