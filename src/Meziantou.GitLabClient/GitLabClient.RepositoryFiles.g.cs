// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated
// </auto-generated>
// ------------------------------------------------------------------------------
#nullable enable
namespace Meziantou.GitLab
{
    public partial interface IGitLabClient
    {
        Meziantou.GitLab.IGitLabRepositoryFilesClient RepositoryFiles
        {
            get;
        }
    }

    public partial interface IGitLabRepositoryFilesClient
    {
        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/repository/files/:file_path</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/repository_files.html#create-new-file-in-repository" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<FileCreated> CreateFileAsync(Meziantou.GitLab.CreateFileRepositoryFileRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>PUT /projects/:id/repository/files/:file_path</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/repository_files.html#update-existing-file-in-repository" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<FileUpdated> UpdateFileAsync(Meziantou.GitLab.UpdateFileRepositoryFileRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
    }

    public partial class GitLabClient : Meziantou.GitLab.IGitLabRepositoryFilesClient
    {
        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/repository/files/:file_path</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/repository_files.html#create-new-file-in-repository" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<FileCreated> Meziantou.GitLab.IGitLabRepositoryFilesClient.CreateFileAsync(Meziantou.GitLab.CreateFileRepositoryFileRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.RepositoryFiles_CreateFileAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>PUT /projects/:id/repository/files/:file_path</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/repository_files.html#update-existing-file-in-repository" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<FileUpdated> Meziantou.GitLab.IGitLabRepositoryFilesClient.UpdateFileAsync(Meziantou.GitLab.UpdateFileRepositoryFileRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.RepositoryFiles_UpdateFileAsync(request, requestOptions, cancellationToken);
        }

        public Meziantou.GitLab.IGitLabRepositoryFilesClient RepositoryFiles
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/repository/files/:file_path</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/repository_files.html#create-new-file-in-repository" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<FileCreated> RepositoryFiles_CreateFileAsync(Meziantou.GitLab.CreateFileRepositoryFileRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.RepositoryFiles_CreateFileAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Post;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                Meziantou.GitLab.Internals.UnsafeListDictionary<string, object> body = new Meziantou.GitLab.Internals.UnsafeListDictionary<string, object>(6);
                if ((request.Branch != null))
                {
                    body.Add("branch", request.Branch);
                }

                if ((request.Content != null))
                {
                    body.Add("content", request.Content);
                }

                if ((request.CommitMessage != null))
                {
                    body.Add("commit_message", request.CommitMessage);
                }

                if ((request.StartBranch != null))
                {
                    body.Add("start_branch", request.StartBranch);
                }

                if ((request.AuthorEmail != null))
                {
                    body.Add("author_email", request.AuthorEmail);
                }

                if ((request.AuthorName != null))
                {
                    body.Add("author_name", request.AuthorName);
                }

                requestMessage.Content = new Meziantou.GitLab.Internals.JsonContent(body, Meziantou.GitLab.Serialization.JsonSerialization.Options);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    FileCreated? result = await response.ToObjectAsync<FileCreated>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'FileCreated' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string RepositoryFiles_CreateFileAsync_BuildUrl(Meziantou.GitLab.CreateFileRepositoryFileRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("projects/");
                if (request.Id.HasValue)
                {
                    urlBuilder.AppendParameter(request.Id.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/repository/files/");
                if ((!object.ReferenceEquals(request.FilePath, null)))
                {
                    urlBuilder.AppendParameter(request.FilePath);
                }

                url = urlBuilder.ToString();
            }

            return url;
        }

        /// <summary>
        ///   <para>URL: <c>PUT /projects/:id/repository/files/:file_path</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/repository_files.html#update-existing-file-in-repository" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<FileUpdated> RepositoryFiles_UpdateFileAsync(Meziantou.GitLab.UpdateFileRepositoryFileRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.RepositoryFiles_UpdateFileAsync_BuildUrl(request);
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Put;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                Meziantou.GitLab.Internals.UnsafeListDictionary<string, object> body = new Meziantou.GitLab.Internals.UnsafeListDictionary<string, object>(7);
                if ((request.Branch != null))
                {
                    body.Add("branch", request.Branch);
                }

                if ((request.Content != null))
                {
                    body.Add("content", request.Content);
                }

                if ((request.CommitMessage != null))
                {
                    body.Add("commit_message", request.CommitMessage);
                }

                if ((request.StartBranch != null))
                {
                    body.Add("start_branch", request.StartBranch);
                }

                if ((request.AuthorEmail != null))
                {
                    body.Add("author_email", request.AuthorEmail);
                }

                if ((request.AuthorName != null))
                {
                    body.Add("author_name", request.AuthorName);
                }

                if ((request.LastCommitId != null))
                {
                    body.Add("last_commit_id", request.LastCommitId);
                }

                requestMessage.Content = new Meziantou.GitLab.Internals.JsonContent(body, Meziantou.GitLab.Serialization.JsonSerialization.Options);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    FileUpdated? result = await response.ToObjectAsync<FileUpdated>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'FileUpdated' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private static string RepositoryFiles_UpdateFileAsync_BuildUrl(Meziantou.GitLab.UpdateFileRepositoryFileRequest request)
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("projects/");
                if (request.Id.HasValue)
                {
                    urlBuilder.AppendParameter(request.Id.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/repository/files/");
                if ((!object.ReferenceEquals(request.FilePath, null)))
                {
                    urlBuilder.AppendParameter(request.FilePath);
                }

                url = urlBuilder.ToString();
            }

            return url;
        }
    }

    public static partial class GitLabClientExtensions
    {
        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/repository/files/:file_path</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/repository_files.html#create-new-file-in-repository" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<FileCreated> CreateFileAsync(this Meziantou.GitLab.IGitLabRepositoryFilesClient client, ProjectIdOrPathRef id, string filePath, string branch, Meziantou.GitLab.TextOrBinaryData content, string commitMessage, string? startBranch = default(string?), string? authorEmail = default(string?), string? authorName = default(string?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.CreateFileRepositoryFileRequest request = new Meziantou.GitLab.CreateFileRepositoryFileRequest(id, filePath, branch, content, commitMessage);
            request.StartBranch = startBranch;
            request.AuthorEmail = authorEmail;
            request.AuthorName = authorName;
            return client.CreateFileAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>PUT /projects/:id/repository/files/:file_path</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/repository_files.html#update-existing-file-in-repository" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<FileUpdated> UpdateFileAsync(this Meziantou.GitLab.IGitLabRepositoryFilesClient client, ProjectIdOrPathRef id, string filePath, string branch, Meziantou.GitLab.TextOrBinaryData content, string commitMessage, string? startBranch = default(string?), string? authorEmail = default(string?), string? authorName = default(string?), Meziantou.GitLab.GitObjectId? lastCommitId = default(Meziantou.GitLab.GitObjectId?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.UpdateFileRepositoryFileRequest request = new Meziantou.GitLab.UpdateFileRepositoryFileRequest(id, filePath, branch, content, commitMessage);
            request.StartBranch = startBranch;
            request.AuthorEmail = authorEmail;
            request.AuthorName = authorName;
            request.LastCommitId = lastCommitId;
            return client.UpdateFileAsync(request, requestOptions, cancellationToken);
        }
    }

    public partial class CreateFileRepositoryFileRequest
    {
        private string? _authorEmail;

        private string? _authorName;

        private string? _branch;

        private string? _commitMessage;

        private Meziantou.GitLab.TextOrBinaryData? _content;

        private string? _filePath;

        private ProjectIdOrPathRef? _id;

        private string? _startBranch;

        public CreateFileRepositoryFileRequest(ProjectIdOrPathRef? id, string? filePath, string? branch, Meziantou.GitLab.TextOrBinaryData? content, string? commitMessage)
        {
            this._id = id;
            this._filePath = filePath;
            this._branch = branch;
            this._content = content;
            this._commitMessage = commitMessage;
        }

        public CreateFileRepositoryFileRequest()
        {
        }

        public string? AuthorEmail
        {
            get
            {
                return this._authorEmail;
            }
            set
            {
                this._authorEmail = value;
            }
        }

        public string? AuthorName
        {
            get
            {
                return this._authorName;
            }
            set
            {
                this._authorName = value;
            }
        }

        public string? Branch
        {
            get
            {
                return this._branch;
            }
            set
            {
                this._branch = value;
            }
        }

        public string? CommitMessage
        {
            get
            {
                return this._commitMessage;
            }
            set
            {
                this._commitMessage = value;
            }
        }

        public Meziantou.GitLab.TextOrBinaryData? Content
        {
            get
            {
                return this._content;
            }
            set
            {
                this._content = value;
            }
        }

        public string? FilePath
        {
            get
            {
                return this._filePath;
            }
            set
            {
                this._filePath = value;
            }
        }

        public ProjectIdOrPathRef? Id
        {
            get
            {
                return this._id;
            }
            set
            {
                this._id = value;
            }
        }

        public string? StartBranch
        {
            get
            {
                return this._startBranch;
            }
            set
            {
                this._startBranch = value;
            }
        }
    }

    public partial class UpdateFileRepositoryFileRequest
    {
        private string? _authorEmail;

        private string? _authorName;

        private string? _branch;

        private string? _commitMessage;

        private Meziantou.GitLab.TextOrBinaryData? _content;

        private string? _filePath;

        private ProjectIdOrPathRef? _id;

        private Meziantou.GitLab.GitObjectId? _lastCommitId;

        private string? _startBranch;

        public UpdateFileRepositoryFileRequest(ProjectIdOrPathRef? id, string? filePath, string? branch, Meziantou.GitLab.TextOrBinaryData? content, string? commitMessage)
        {
            this._id = id;
            this._filePath = filePath;
            this._branch = branch;
            this._content = content;
            this._commitMessage = commitMessage;
        }

        public UpdateFileRepositoryFileRequest()
        {
        }

        public string? AuthorEmail
        {
            get
            {
                return this._authorEmail;
            }
            set
            {
                this._authorEmail = value;
            }
        }

        public string? AuthorName
        {
            get
            {
                return this._authorName;
            }
            set
            {
                this._authorName = value;
            }
        }

        public string? Branch
        {
            get
            {
                return this._branch;
            }
            set
            {
                this._branch = value;
            }
        }

        public string? CommitMessage
        {
            get
            {
                return this._commitMessage;
            }
            set
            {
                this._commitMessage = value;
            }
        }

        public Meziantou.GitLab.TextOrBinaryData? Content
        {
            get
            {
                return this._content;
            }
            set
            {
                this._content = value;
            }
        }

        public string? FilePath
        {
            get
            {
                return this._filePath;
            }
            set
            {
                this._filePath = value;
            }
        }

        public ProjectIdOrPathRef? Id
        {
            get
            {
                return this._id;
            }
            set
            {
                this._id = value;
            }
        }

        public Meziantou.GitLab.GitObjectId? LastCommitId
        {
            get
            {
                return this._lastCommitId;
            }
            set
            {
                this._lastCommitId = value;
            }
        }

        public string? StartBranch
        {
            get
            {
                return this._startBranch;
            }
            set
            {
                this._startBranch = value;
            }
        }
    }
}
