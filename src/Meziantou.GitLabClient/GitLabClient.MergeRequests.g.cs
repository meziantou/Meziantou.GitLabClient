// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated
// </auto-generated>
// ------------------------------------------------------------------------------
#nullable enable
namespace Meziantou.GitLab
{
    public partial interface IGitLabClient
    {
        Meziantou.GitLab.IGitLabMergeRequestsClient MergeRequests
        {
            get;
        }
    }

    public partial interface IGitLabMergeRequestsClient
    {
        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#create-mr" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<MergeRequest> CreateMergeRequestAsync(Meziantou.GitLab.CreateMergeRequestRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>GET /groups/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-group-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<MergeRequest> GetGroupMergeRequests(Meziantou.GitLab.GetGroupMergeRequestsRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions));

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id/merge_requests/:merge_request_iid</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#get-single-mr" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<MergeRequest?> GetMergeRequestAsync(Meziantou.GitLab.GetMergeRequestRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        ///   <para>URL: <c>GET /merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<MergeRequest> GetMergeRequests(Meziantou.GitLab.GetMergeRequestsRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions));

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-project-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<MergeRequest> GetProjectMergeRequests(Meziantou.GitLab.GetProjectMergeRequestsRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions));
    }

    public partial class GitLabClient : Meziantou.GitLab.IGitLabMergeRequestsClient
    {
        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#create-mr" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<MergeRequest> Meziantou.GitLab.IGitLabMergeRequestsClient.CreateMergeRequestAsync(Meziantou.GitLab.CreateMergeRequestRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.MergeRequests_CreateMergeRequestAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /groups/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-group-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<MergeRequest> Meziantou.GitLab.IGitLabMergeRequestsClient.GetGroupMergeRequests(Meziantou.GitLab.GetGroupMergeRequestsRequest request, Meziantou.GitLab.RequestOptions? requestOptions)
        {
            return this.MergeRequests_GetGroupMergeRequests(request, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id/merge_requests/:merge_request_iid</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#get-single-mr" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<MergeRequest?> Meziantou.GitLab.IGitLabMergeRequestsClient.GetMergeRequestAsync(Meziantou.GitLab.GetMergeRequestRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.MergeRequests_GetMergeRequestAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<MergeRequest> Meziantou.GitLab.IGitLabMergeRequestsClient.GetMergeRequests(Meziantou.GitLab.GetMergeRequestsRequest request, Meziantou.GitLab.RequestOptions? requestOptions)
        {
            return this.MergeRequests_GetMergeRequests(request, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-project-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        Meziantou.GitLab.PagedResponse<MergeRequest> Meziantou.GitLab.IGitLabMergeRequestsClient.GetProjectMergeRequests(Meziantou.GitLab.GetProjectMergeRequestsRequest request, Meziantou.GitLab.RequestOptions? requestOptions)
        {
            return this.MergeRequests_GetProjectMergeRequests(request, requestOptions);
        }

        public Meziantou.GitLab.IGitLabMergeRequestsClient MergeRequests
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#create-mr" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private System.Threading.Tasks.Task<MergeRequest> MergeRequests_CreateMergeRequestAsync(Meziantou.GitLab.CreateMergeRequestRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("projects/");
                if (request.Id.HasValue)
                {
                    urlBuilder.AppendParameter(request.Id.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/merge_requests");
                url = urlBuilder.ToString();
            }

            System.Collections.Generic.Dictionary<string, object> body = new System.Collections.Generic.Dictionary<string, object>();
            if ((request.SourceBranch != null))
            {
                body.Add("source_branch", request.SourceBranch);
            }

            if ((request.TargetBranch != null))
            {
                body.Add("target_branch", request.TargetBranch);
            }

            if ((request.Title != null))
            {
                body.Add("title", request.Title);
            }

            if ((request.Description != null))
            {
                body.Add("description", request.Description);
            }

            if ((request.AssigneeId != null))
            {
                body.Add("assignee_id", request.AssigneeId);
            }

            if ((request.TargetProjectId != null))
            {
                body.Add("target_project_id", request.TargetProjectId);
            }

            if ((request.RemoveSourceBranch != null))
            {
                body.Add("remove_source_branch", request.RemoveSourceBranch);
            }

            if ((request.AllowCollaboration != null))
            {
                body.Add("allow_collaboration", request.AllowCollaboration);
            }

            if ((request.AllowMaintainerToPush != null))
            {
                body.Add("allow_maintainer_to_push", request.AllowMaintainerToPush);
            }

            if ((request.Squash != null))
            {
                body.Add("squash", request.Squash);
            }

            return this.PostJsonAsync<MergeRequest>(url, body, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /groups/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-group-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private Meziantou.GitLab.PagedResponse<MergeRequest> MergeRequests_GetGroupMergeRequests(Meziantou.GitLab.GetGroupMergeRequestsRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("groups/");
                if (request.Id.HasValue)
                {
                    urlBuilder.AppendParameter(request.Id.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/merge_requests");
                char separator = '?';
                if (request.State.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("state=");
                    urlBuilder.AppendParameter(request.State.GetValueOrDefault());
                }

                if (request.Scope.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("scope=");
                    urlBuilder.AppendParameter(request.Scope.GetValueOrDefault());
                }

                if (request.AssigneeId.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("assignee_id=");
                    urlBuilder.AppendParameter(request.AssigneeId.GetValueOrDefault().ValueAsString);
                }

                if (request.AuthorId.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("author_id=");
                    urlBuilder.AppendParameter(request.AuthorId.GetValueOrDefault().ValueAsString);
                }

                if ((!object.ReferenceEquals(request.Milestone, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("milestone=");
                    urlBuilder.AppendParameter(request.Milestone);
                }

                if (request.View.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("view=");
                    urlBuilder.AppendParameter(request.View.GetValueOrDefault());
                }

                if ((!object.ReferenceEquals(request.Labels, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("labels=");
                    urlBuilder.AppendParameter(request.Labels);
                }

                if (request.CreatedAfter.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("created_after=");
                    urlBuilder.AppendParameter(request.CreatedAfter.GetValueOrDefault());
                }

                if (request.CreatedBefore.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("created_before=");
                    urlBuilder.AppendParameter(request.CreatedBefore.GetValueOrDefault());
                }

                if (request.UpdatedAfter.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("updated_after=");
                    urlBuilder.AppendParameter(request.UpdatedAfter.GetValueOrDefault());
                }

                if (request.UpdatedBefore.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("updated_before=");
                    urlBuilder.AppendParameter(request.UpdatedBefore.GetValueOrDefault());
                }

                if ((!object.ReferenceEquals(request.MyReactionEmoji, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("my_reaction_emoji=");
                    urlBuilder.AppendParameter(request.MyReactionEmoji);
                }

                if ((!object.ReferenceEquals(request.SourceBranch, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("source_branch=");
                    urlBuilder.AppendParameter(request.SourceBranch);
                }

                if ((!object.ReferenceEquals(request.TargetBranch, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("target_branch=");
                    urlBuilder.AppendParameter(request.TargetBranch);
                }

                if ((!object.ReferenceEquals(request.Search, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("search=");
                    urlBuilder.AppendParameter(request.Search);
                }

                url = urlBuilder.ToString();
            }

            return new Meziantou.GitLab.PagedResponse<MergeRequest>(this, url, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id/merge_requests/:merge_request_iid</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#get-single-mr" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private System.Threading.Tasks.Task<MergeRequest?> MergeRequests_GetMergeRequestAsync(Meziantou.GitLab.GetMergeRequestRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("projects/");
                if (request.Id.HasValue)
                {
                    urlBuilder.AppendParameter(request.Id.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/merge_requests/");
                if (request.MergeRequestIid.HasValue)
                {
                    urlBuilder.AppendParameter(request.MergeRequestIid.GetValueOrDefault().Value);
                }

                url = urlBuilder.ToString();
            }

            return this.GetAsync<MergeRequest>(url, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private Meziantou.GitLab.PagedResponse<MergeRequest> MergeRequests_GetMergeRequests(Meziantou.GitLab.GetMergeRequestsRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("merge_requests");
                char separator = '?';
                if (request.State.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("state=");
                    urlBuilder.AppendParameter(request.State.GetValueOrDefault());
                }

                if (request.Scope.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("scope=");
                    urlBuilder.AppendParameter(request.Scope.GetValueOrDefault());
                }

                if (request.AssigneeId.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("assignee_id=");
                    urlBuilder.AppendParameter(request.AssigneeId.GetValueOrDefault().ValueAsString);
                }

                if (request.AuthorId.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("author_id=");
                    urlBuilder.AppendParameter(request.AuthorId.GetValueOrDefault().ValueAsString);
                }

                if ((!object.ReferenceEquals(request.Milestone, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("milestone=");
                    urlBuilder.AppendParameter(request.Milestone);
                }

                if (request.View.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("view=");
                    urlBuilder.AppendParameter(request.View.GetValueOrDefault());
                }

                if ((!object.ReferenceEquals(request.Labels, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("labels=");
                    urlBuilder.AppendParameter(request.Labels);
                }

                if (request.CreatedAfter.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("created_after=");
                    urlBuilder.AppendParameter(request.CreatedAfter.GetValueOrDefault());
                }

                if (request.CreatedBefore.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("created_before=");
                    urlBuilder.AppendParameter(request.CreatedBefore.GetValueOrDefault());
                }

                if (request.UpdatedAfter.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("updated_after=");
                    urlBuilder.AppendParameter(request.UpdatedAfter.GetValueOrDefault());
                }

                if (request.UpdatedBefore.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("updated_before=");
                    urlBuilder.AppendParameter(request.UpdatedBefore.GetValueOrDefault());
                }

                if ((!object.ReferenceEquals(request.MyReactionEmoji, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("my_reaction_emoji=");
                    urlBuilder.AppendParameter(request.MyReactionEmoji);
                }

                if ((!object.ReferenceEquals(request.SourceBranch, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("source_branch=");
                    urlBuilder.AppendParameter(request.SourceBranch);
                }

                if ((!object.ReferenceEquals(request.TargetBranch, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("target_branch=");
                    urlBuilder.AppendParameter(request.TargetBranch);
                }

                if ((!object.ReferenceEquals(request.Search, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("search=");
                    urlBuilder.AppendParameter(request.Search);
                }

                url = urlBuilder.ToString();
            }

            return new Meziantou.GitLab.PagedResponse<MergeRequest>(this, url, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-project-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Reliability", "CA2000:Dispose objects before losing scope", Justification = "The rule doesn't understand ref struct")]
        private Meziantou.GitLab.PagedResponse<MergeRequest> MergeRequests_GetProjectMergeRequests(Meziantou.GitLab.GetProjectMergeRequestsRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            string url;
            using (Meziantou.GitLab.Internals.UrlBuilder urlBuilder = new Meziantou.GitLab.Internals.UrlBuilder())
            {
                urlBuilder.Append("projects/");
                if (request.Id.HasValue)
                {
                    urlBuilder.AppendParameter(request.Id.GetValueOrDefault().ValueAsString);
                }

                urlBuilder.Append("/merge_requests");
                char separator = '?';
                if ((!object.ReferenceEquals(request.Iids, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("iids=");
                    urlBuilder.AppendParameter(request.Iids);
                }

                if (request.State.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("state=");
                    urlBuilder.AppendParameter(request.State.GetValueOrDefault());
                }

                if (request.Scope.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("scope=");
                    urlBuilder.AppendParameter(request.Scope.GetValueOrDefault());
                }

                if (request.AssigneeId.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("assignee_id=");
                    urlBuilder.AppendParameter(request.AssigneeId.GetValueOrDefault().ValueAsString);
                }

                if (request.AuthorId.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("author_id=");
                    urlBuilder.AppendParameter(request.AuthorId.GetValueOrDefault().ValueAsString);
                }

                if ((!object.ReferenceEquals(request.Milestone, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("milestone=");
                    urlBuilder.AppendParameter(request.Milestone);
                }

                if (request.View.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("view=");
                    urlBuilder.AppendParameter(request.View.GetValueOrDefault());
                }

                if ((!object.ReferenceEquals(request.Labels, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("labels=");
                    urlBuilder.AppendParameter(request.Labels);
                }

                if (request.CreatedAfter.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("created_after=");
                    urlBuilder.AppendParameter(request.CreatedAfter.GetValueOrDefault());
                }

                if (request.CreatedBefore.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("created_before=");
                    urlBuilder.AppendParameter(request.CreatedBefore.GetValueOrDefault());
                }

                if (request.UpdatedAfter.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("updated_after=");
                    urlBuilder.AppendParameter(request.UpdatedAfter.GetValueOrDefault());
                }

                if (request.UpdatedBefore.HasValue)
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("updated_before=");
                    urlBuilder.AppendParameter(request.UpdatedBefore.GetValueOrDefault());
                }

                if ((!object.ReferenceEquals(request.MyReactionEmoji, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("my_reaction_emoji=");
                    urlBuilder.AppendParameter(request.MyReactionEmoji);
                }

                if ((!object.ReferenceEquals(request.SourceBranch, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("source_branch=");
                    urlBuilder.AppendParameter(request.SourceBranch);
                }

                if ((!object.ReferenceEquals(request.TargetBranch, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("target_branch=");
                    urlBuilder.AppendParameter(request.TargetBranch);
                }

                if ((!object.ReferenceEquals(request.Search, null)))
                {
                    urlBuilder.Append(separator);
                    separator = '&';
                    urlBuilder.Append("search=");
                    urlBuilder.AppendParameter(request.Search);
                }

                url = urlBuilder.ToString();
            }

            return new Meziantou.GitLab.PagedResponse<MergeRequest>(this, url, requestOptions);
        }
    }

    public static partial class GitLabClientExtensions
    {
        /// <summary>
        ///   <para>URL: <c>POST /projects/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#create-mr" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<MergeRequest> CreateMergeRequestAsync(this Meziantou.GitLab.IGitLabMergeRequestsClient client, ProjectIdOrPathRef id, string sourceBranch, string targetBranch, string title, string? description = default(string?), UserRef? assigneeId = default(UserRef?), ProjectIdRef? targetProjectId = default(ProjectIdRef?), bool? removeSourceBranch = default(bool?), bool? allowCollaboration = default(bool?), bool? allowMaintainerToPush = default(bool?), bool? squash = default(bool?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.CreateMergeRequestRequest request = new Meziantou.GitLab.CreateMergeRequestRequest(id, sourceBranch, targetBranch, title);
            request.Description = description;
            request.AssigneeId = assigneeId;
            request.TargetProjectId = targetProjectId;
            request.RemoveSourceBranch = removeSourceBranch;
            request.AllowCollaboration = allowCollaboration;
            request.AllowMaintainerToPush = allowMaintainerToPush;
            request.Squash = squash;
            return client.CreateMergeRequestAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /groups/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-group-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        public static Meziantou.GitLab.PagedResponse<MergeRequest> GetGroupMergeRequests(this Meziantou.GitLab.IGitLabMergeRequestsClient client, GroupIdOrPathRef id, MergeRequestState? state = default(MergeRequestState?), MergeRequestScopeFilter? scope = default(MergeRequestScopeFilter?), UserRef? assigneeId = default(UserRef?), UserRef? authorId = default(UserRef?), string? milestone = default(string?), MergeRequestView? view = default(MergeRequestView?), System.Collections.Generic.IEnumerable<string>? labels = default(System.Collections.Generic.IEnumerable<string>?), System.DateTimeOffset? createdAfter = default(System.DateTimeOffset?), System.DateTimeOffset? createdBefore = default(System.DateTimeOffset?), System.DateTimeOffset? updatedAfter = default(System.DateTimeOffset?), System.DateTimeOffset? updatedBefore = default(System.DateTimeOffset?), string? myReactionEmoji = default(string?), string? sourceBranch = default(string?), string? targetBranch = default(string?), string? search = default(string?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            Meziantou.GitLab.GetGroupMergeRequestsRequest request = new Meziantou.GitLab.GetGroupMergeRequestsRequest(id);
            request.State = state;
            request.Scope = scope;
            request.AssigneeId = assigneeId;
            request.AuthorId = authorId;
            request.Milestone = milestone;
            request.View = view;
            request.Labels = labels;
            request.CreatedAfter = createdAfter;
            request.CreatedBefore = createdBefore;
            request.UpdatedAfter = updatedAfter;
            request.UpdatedBefore = updatedBefore;
            request.MyReactionEmoji = myReactionEmoji;
            request.SourceBranch = sourceBranch;
            request.TargetBranch = targetBranch;
            request.Search = search;
            return client.GetGroupMergeRequests(request, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id/merge_requests/:merge_request_iid</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#get-single-mr" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<MergeRequest?> GetMergeRequestAsync(this Meziantou.GitLab.IGitLabMergeRequestsClient client, ProjectIdOrPathRef id, MergeRequestIidRef mergeRequestIid, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.GetMergeRequestRequest request = new Meziantou.GitLab.GetMergeRequestRequest(id, mergeRequestIid);
            return client.GetMergeRequestAsync(request, requestOptions, cancellationToken);
        }

        /// <summary>
        ///   <para>URL: <c>GET /merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        public static Meziantou.GitLab.PagedResponse<MergeRequest> GetMergeRequests(this Meziantou.GitLab.IGitLabMergeRequestsClient client, MergeRequestState? state = default(MergeRequestState?), MergeRequestScopeFilter? scope = default(MergeRequestScopeFilter?), UserRef? assigneeId = default(UserRef?), UserRef? authorId = default(UserRef?), string? milestone = default(string?), MergeRequestView? view = default(MergeRequestView?), System.Collections.Generic.IEnumerable<string>? labels = default(System.Collections.Generic.IEnumerable<string>?), System.DateTimeOffset? createdAfter = default(System.DateTimeOffset?), System.DateTimeOffset? createdBefore = default(System.DateTimeOffset?), System.DateTimeOffset? updatedAfter = default(System.DateTimeOffset?), System.DateTimeOffset? updatedBefore = default(System.DateTimeOffset?), string? myReactionEmoji = default(string?), string? sourceBranch = default(string?), string? targetBranch = default(string?), string? search = default(string?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            Meziantou.GitLab.GetMergeRequestsRequest request = new Meziantou.GitLab.GetMergeRequestsRequest();
            request.State = state;
            request.Scope = scope;
            request.AssigneeId = assigneeId;
            request.AuthorId = authorId;
            request.Milestone = milestone;
            request.View = view;
            request.Labels = labels;
            request.CreatedAfter = createdAfter;
            request.CreatedBefore = createdBefore;
            request.UpdatedAfter = updatedAfter;
            request.UpdatedBefore = updatedBefore;
            request.MyReactionEmoji = myReactionEmoji;
            request.SourceBranch = sourceBranch;
            request.TargetBranch = targetBranch;
            request.Search = search;
            return client.GetMergeRequests(request, requestOptions);
        }

        /// <summary>
        ///   <para>URL: <c>GET /projects/:id/merge_requests</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/merge_requests.html#list-project-merge-requests" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        public static Meziantou.GitLab.PagedResponse<MergeRequest> GetProjectMergeRequests(this Meziantou.GitLab.IGitLabMergeRequestsClient client, ProjectIdOrPathRef id, System.Collections.Generic.IEnumerable<long>? iids = default(System.Collections.Generic.IEnumerable<long>?), MergeRequestState? state = default(MergeRequestState?), MergeRequestScopeFilter? scope = default(MergeRequestScopeFilter?), UserRef? assigneeId = default(UserRef?), UserRef? authorId = default(UserRef?), string? milestone = default(string?), MergeRequestView? view = default(MergeRequestView?), System.Collections.Generic.IEnumerable<string>? labels = default(System.Collections.Generic.IEnumerable<string>?), System.DateTimeOffset? createdAfter = default(System.DateTimeOffset?), System.DateTimeOffset? createdBefore = default(System.DateTimeOffset?), System.DateTimeOffset? updatedAfter = default(System.DateTimeOffset?), System.DateTimeOffset? updatedBefore = default(System.DateTimeOffset?), string? myReactionEmoji = default(string?), string? sourceBranch = default(string?), string? targetBranch = default(string?), string? search = default(string?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions))
        {
            Meziantou.GitLab.GetProjectMergeRequestsRequest request = new Meziantou.GitLab.GetProjectMergeRequestsRequest(id);
            request.Iids = iids;
            request.State = state;
            request.Scope = scope;
            request.AssigneeId = assigneeId;
            request.AuthorId = authorId;
            request.Milestone = milestone;
            request.View = view;
            request.Labels = labels;
            request.CreatedAfter = createdAfter;
            request.CreatedBefore = createdBefore;
            request.UpdatedAfter = updatedAfter;
            request.UpdatedBefore = updatedBefore;
            request.MyReactionEmoji = myReactionEmoji;
            request.SourceBranch = sourceBranch;
            request.TargetBranch = targetBranch;
            request.Search = search;
            return client.GetProjectMergeRequests(request, requestOptions);
        }
    }

    public partial class GetMergeRequestsRequest
    {
        private UserRef? _assigneeId;

        private UserRef? _authorId;

        private System.DateTimeOffset? _createdAfter;

        private System.DateTimeOffset? _createdBefore;

        private System.Collections.Generic.IEnumerable<string>? _labels;

        private string? _milestone;

        private string? _myReactionEmoji;

        private MergeRequestScopeFilter? _scope;

        private string? _search;

        private string? _sourceBranch;

        private MergeRequestState? _state;

        private string? _targetBranch;

        private System.DateTimeOffset? _updatedAfter;

        private System.DateTimeOffset? _updatedBefore;

        private MergeRequestView? _view;

        public GetMergeRequestsRequest()
        {
        }

        /// <summary>
        ///   <para>Returns merge requests assigned to the given user id. None returns unassigned merge requests. Any returns merge requests with an assignee.</para>
        /// </summary>
        public UserRef? AssigneeId
        {
            get
            {
                return this._assigneeId;
            }
            set
            {
                this._assigneeId = value;
            }
        }

        /// <summary>
        ///   <para>Returns merge requests created by the given user id. Mutually exclusive with author_username. Combine with scope=all or scope=assigned_to_me.</para>
        /// </summary>
        public UserRef? AuthorId
        {
            get
            {
                return this._authorId;
            }
            set
            {
                this._authorId = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests created on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)</para>
        /// </summary>
        public System.DateTimeOffset? CreatedAfter
        {
            get
            {
                return this._createdAfter;
            }
            set
            {
                this._createdAfter = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests created on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)</para>
        /// </summary>
        public System.DateTimeOffset? CreatedBefore
        {
            get
            {
                return this._createdBefore;
            }
            set
            {
                this._createdBefore = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests matching a comma separated list of labels. None lists all merge requests with no labels. Any lists all merge requests with at least one label. No+Label (Deprecated) lists all merge requests with no labels. Predefined names are case-insensitive.</para>
        /// </summary>
        public System.Collections.Generic.IEnumerable<string>? Labels
        {
            get
            {
                return this._labels;
            }
            set
            {
                this._labels = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests for a specific milestone. None returns merge requests with no milestone. Any returns merge requests that have an assigned milestone.</para>
        /// </summary>
        public string? Milestone
        {
            get
            {
                return this._milestone;
            }
            set
            {
                this._milestone = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests reacted by the authenticated user by the given emoji. None returns issues not given a reaction. Any returns issues given at least one reaction.</para>
        /// </summary>
        public string? MyReactionEmoji
        {
            get
            {
                return this._myReactionEmoji;
            }
            set
            {
                this._myReactionEmoji = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests for the given scope: created_by_me, assigned_to_me or all. Defaults to created_by_me For versions before 11.0, use the now deprecated created-by-me or assigned-to-me scopes instead.</para>
        /// </summary>
        public MergeRequestScopeFilter? Scope
        {
            get
            {
                return this._scope;
            }
            set
            {
                this._scope = value;
            }
        }

        /// <summary>
        ///   <para>Search merge requests against their title and description.</para>
        /// </summary>
        public string? Search
        {
            get
            {
                return this._search;
            }
            set
            {
                this._search = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests with the given source branch.</para>
        /// </summary>
        public string? SourceBranch
        {
            get
            {
                return this._sourceBranch;
            }
            set
            {
                this._sourceBranch = value;
            }
        }

        /// <summary>
        ///   <para>Return all merge requests or just those that are opened, closed, locked, or merged.</para>
        /// </summary>
        public MergeRequestState? State
        {
            get
            {
                return this._state;
            }
            set
            {
                this._state = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests with the given target branch.</para>
        /// </summary>
        public string? TargetBranch
        {
            get
            {
                return this._targetBranch;
            }
            set
            {
                this._targetBranch = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests updated on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)</para>
        /// </summary>
        public System.DateTimeOffset? UpdatedAfter
        {
            get
            {
                return this._updatedAfter;
            }
            set
            {
                this._updatedAfter = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests updated on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)</para>
        /// </summary>
        public System.DateTimeOffset? UpdatedBefore
        {
            get
            {
                return this._updatedBefore;
            }
            set
            {
                this._updatedBefore = value;
            }
        }

        /// <summary>
        ///   <para>If simple, returns the iid, URL, title, description, and basic state of merge request.</para>
        /// </summary>
        public MergeRequestView? View
        {
            get
            {
                return this._view;
            }
            set
            {
                this._view = value;
            }
        }
    }

    public partial class GetGroupMergeRequestsRequest
    {
        private UserRef? _assigneeId;

        private UserRef? _authorId;

        private System.DateTimeOffset? _createdAfter;

        private System.DateTimeOffset? _createdBefore;

        private GroupIdOrPathRef? _id;

        private System.Collections.Generic.IEnumerable<string>? _labels;

        private string? _milestone;

        private string? _myReactionEmoji;

        private MergeRequestScopeFilter? _scope;

        private string? _search;

        private string? _sourceBranch;

        private MergeRequestState? _state;

        private string? _targetBranch;

        private System.DateTimeOffset? _updatedAfter;

        private System.DateTimeOffset? _updatedBefore;

        private MergeRequestView? _view;

        /// <param name="id">The ID of a group.</param>
        public GetGroupMergeRequestsRequest(GroupIdOrPathRef? id)
        {
            this._id = id;
        }

        public GetGroupMergeRequestsRequest()
        {
        }

        /// <summary>
        ///   <para>Returns merge requests assigned to the given user id. None returns unassigned merge requests. Any returns merge requests with an assignee. (Introduced in GitLab 9.5).</para>
        /// </summary>
        public UserRef? AssigneeId
        {
            get
            {
                return this._assigneeId;
            }
            set
            {
                this._assigneeId = value;
            }
        }

        /// <summary>
        ///   <para>Returns merge requests created by the given user id. Mutually exclusive with author_username. (Introduced in GitLab 9.5).</para>
        /// </summary>
        public UserRef? AuthorId
        {
            get
            {
                return this._authorId;
            }
            set
            {
                this._authorId = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests created on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z).</para>
        /// </summary>
        public System.DateTimeOffset? CreatedAfter
        {
            get
            {
                return this._createdAfter;
            }
            set
            {
                this._createdAfter = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests created on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z).</para>
        /// </summary>
        public System.DateTimeOffset? CreatedBefore
        {
            get
            {
                return this._createdBefore;
            }
            set
            {
                this._createdBefore = value;
            }
        }

        /// <summary>
        ///   <para>The ID of a group.</para>
        /// </summary>
        public GroupIdOrPathRef? Id
        {
            get
            {
                return this._id;
            }
            set
            {
                this._id = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests matching a comma separated list of labels. None lists all merge requests with no labels. Any lists all merge requests with at least one label. No+Label (Deprecated) lists all merge requests with no labels. Predefined names are case-insensitive.</para>
        /// </summary>
        public System.Collections.Generic.IEnumerable<string>? Labels
        {
            get
            {
                return this._labels;
            }
            set
            {
                this._labels = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests for a specific milestone. None returns merge requests with no milestone. Any returns merge requests that have an assigned milestone.</para>
        /// </summary>
        public string? Milestone
        {
            get
            {
                return this._milestone;
            }
            set
            {
                this._milestone = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests reacted by the authenticated user by the given emoji. None returns issues not given a reaction. Any returns issues given at least one reaction. (Introduced in GitLab 10.0).</para>
        /// </summary>
        public string? MyReactionEmoji
        {
            get
            {
                return this._myReactionEmoji;
            }
            set
            {
                this._myReactionEmoji = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests for the given scope: created_by_me, assigned_to_me or all.</para>
        /// </summary>
        public MergeRequestScopeFilter? Scope
        {
            get
            {
                return this._scope;
            }
            set
            {
                this._scope = value;
            }
        }

        /// <summary>
        ///   <para>Search merge requests against their title and description.</para>
        /// </summary>
        public string? Search
        {
            get
            {
                return this._search;
            }
            set
            {
                this._search = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests with the given source branch.</para>
        /// </summary>
        public string? SourceBranch
        {
            get
            {
                return this._sourceBranch;
            }
            set
            {
                this._sourceBranch = value;
            }
        }

        /// <summary>
        ///   <para>Return all merge requests or just those that are opened, closed, locked, or merged.</para>
        /// </summary>
        public MergeRequestState? State
        {
            get
            {
                return this._state;
            }
            set
            {
                this._state = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests with the given target branch.</para>
        /// </summary>
        public string? TargetBranch
        {
            get
            {
                return this._targetBranch;
            }
            set
            {
                this._targetBranch = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests updated on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z).</para>
        /// </summary>
        public System.DateTimeOffset? UpdatedAfter
        {
            get
            {
                return this._updatedAfter;
            }
            set
            {
                this._updatedAfter = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests updated on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z).</para>
        /// </summary>
        public System.DateTimeOffset? UpdatedBefore
        {
            get
            {
                return this._updatedBefore;
            }
            set
            {
                this._updatedBefore = value;
            }
        }

        /// <summary>
        ///   <para>If simple, returns the iid, URL, title, description, and basic state of merge request.</para>
        /// </summary>
        public MergeRequestView? View
        {
            get
            {
                return this._view;
            }
            set
            {
                this._view = value;
            }
        }
    }

    public partial class GetProjectMergeRequestsRequest
    {
        private UserRef? _assigneeId;

        private UserRef? _authorId;

        private System.DateTimeOffset? _createdAfter;

        private System.DateTimeOffset? _createdBefore;

        private ProjectIdOrPathRef? _id;

        private System.Collections.Generic.IEnumerable<long>? _iids;

        private System.Collections.Generic.IEnumerable<string>? _labels;

        private string? _milestone;

        private string? _myReactionEmoji;

        private MergeRequestScopeFilter? _scope;

        private string? _search;

        private string? _sourceBranch;

        private MergeRequestState? _state;

        private string? _targetBranch;

        private System.DateTimeOffset? _updatedAfter;

        private System.DateTimeOffset? _updatedBefore;

        private MergeRequestView? _view;

        /// <param name="id">The ID of a project.</param>
        public GetProjectMergeRequestsRequest(ProjectIdOrPathRef? id)
        {
            this._id = id;
        }

        public GetProjectMergeRequestsRequest()
        {
        }

        /// <summary>
        ///   <para>Returns merge requests assigned to the given user id. None returns unassigned merge requests. Any returns merge requests with an assignee.</para>
        /// </summary>
        public UserRef? AssigneeId
        {
            get
            {
                return this._assigneeId;
            }
            set
            {
                this._assigneeId = value;
            }
        }

        /// <summary>
        ///   <para>Returns merge requests created by the given user id. Mutually exclusive with author_username.</para>
        /// </summary>
        public UserRef? AuthorId
        {
            get
            {
                return this._authorId;
            }
            set
            {
                this._authorId = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests created on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)</para>
        /// </summary>
        public System.DateTimeOffset? CreatedAfter
        {
            get
            {
                return this._createdAfter;
            }
            set
            {
                this._createdAfter = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests created on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)</para>
        /// </summary>
        public System.DateTimeOffset? CreatedBefore
        {
            get
            {
                return this._createdBefore;
            }
            set
            {
                this._createdBefore = value;
            }
        }

        /// <summary>
        ///   <para>The ID of a project.</para>
        /// </summary>
        public ProjectIdOrPathRef? Id
        {
            get
            {
                return this._id;
            }
            set
            {
                this._id = value;
            }
        }

        /// <summary>
        ///   <para>Return the request having the given iid.</para>
        /// </summary>
        public System.Collections.Generic.IEnumerable<long>? Iids
        {
            get
            {
                return this._iids;
            }
            set
            {
                this._iids = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests matching a comma separated list of labels. None lists all merge requests with no labels. Any lists all merge requests with at least one label. No+Label (Deprecated) lists all merge requests with no labels. Predefined names are case-insensitive.</para>
        /// </summary>
        public System.Collections.Generic.IEnumerable<string>? Labels
        {
            get
            {
                return this._labels;
            }
            set
            {
                this._labels = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests for a specific milestone. None returns merge requests with no milestone. Any returns merge requests that have an assigned milestone.</para>
        /// </summary>
        public string? Milestone
        {
            get
            {
                return this._milestone;
            }
            set
            {
                this._milestone = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests reacted by the authenticated user by the given emoji. None returns issues not given a reaction. Any returns issues given at least one reaction.</para>
        /// </summary>
        public string? MyReactionEmoji
        {
            get
            {
                return this._myReactionEmoji;
            }
            set
            {
                this._myReactionEmoji = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests for the given scope: created_by_me, assigned_to_me, or all.</para>
        /// </summary>
        public MergeRequestScopeFilter? Scope
        {
            get
            {
                return this._scope;
            }
            set
            {
                this._scope = value;
            }
        }

        /// <summary>
        ///   <para>Search merge requests against their title and description.</para>
        /// </summary>
        public string? Search
        {
            get
            {
                return this._search;
            }
            set
            {
                this._search = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests with the given source branch.</para>
        /// </summary>
        public string? SourceBranch
        {
            get
            {
                return this._sourceBranch;
            }
            set
            {
                this._sourceBranch = value;
            }
        }

        /// <summary>
        ///   <para>Return all merge requests or just those that are opened, closed, locked, or merged.</para>
        /// </summary>
        public MergeRequestState? State
        {
            get
            {
                return this._state;
            }
            set
            {
                this._state = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests with the given target branch.</para>
        /// </summary>
        public string? TargetBranch
        {
            get
            {
                return this._targetBranch;
            }
            set
            {
                this._targetBranch = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests updated on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)</para>
        /// </summary>
        public System.DateTimeOffset? UpdatedAfter
        {
            get
            {
                return this._updatedAfter;
            }
            set
            {
                this._updatedAfter = value;
            }
        }

        /// <summary>
        ///   <para>Return merge requests updated on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)</para>
        /// </summary>
        public System.DateTimeOffset? UpdatedBefore
        {
            get
            {
                return this._updatedBefore;
            }
            set
            {
                this._updatedBefore = value;
            }
        }

        /// <summary>
        ///   <para>If simple, returns the iid, URL, title, description, and basic state of merge request.</para>
        /// </summary>
        public MergeRequestView? View
        {
            get
            {
                return this._view;
            }
            set
            {
                this._view = value;
            }
        }
    }

    public partial class GetMergeRequestRequest
    {
        private ProjectIdOrPathRef? _id;

        private MergeRequestIidRef? _mergeRequestIid;

        public GetMergeRequestRequest(ProjectIdOrPathRef? id, MergeRequestIidRef? mergeRequestIid)
        {
            this._id = id;
            this._mergeRequestIid = mergeRequestIid;
        }

        public GetMergeRequestRequest()
        {
        }

        public ProjectIdOrPathRef? Id
        {
            get
            {
                return this._id;
            }
            set
            {
                this._id = value;
            }
        }

        public MergeRequestIidRef? MergeRequestIid
        {
            get
            {
                return this._mergeRequestIid;
            }
            set
            {
                this._mergeRequestIid = value;
            }
        }
    }

    public partial class CreateMergeRequestRequest
    {
        private bool? _allowCollaboration;

        private bool? _allowMaintainerToPush;

        private UserRef? _assigneeId;

        private string? _description;

        private ProjectIdOrPathRef? _id;

        private bool? _removeSourceBranch;

        private string? _sourceBranch;

        private bool? _squash;

        private string? _targetBranch;

        private ProjectIdRef? _targetProjectId;

        private string? _title;

        /// <param name="id">The ID or URL-encoded path of the project owned by the authenticated user</param>
        /// <param name="sourceBranch">The source branch.</param>
        /// <param name="targetBranch">The target branch.</param>
        /// <param name="title">Title of MR.</param>
        public CreateMergeRequestRequest(ProjectIdOrPathRef? id, string? sourceBranch, string? targetBranch, string? title)
        {
            this._id = id;
            this._sourceBranch = sourceBranch;
            this._targetBranch = targetBranch;
            this._title = title;
        }

        public CreateMergeRequestRequest()
        {
        }

        /// <summary>
        ///   <para>Allow commits from members who can merge to the target branch.</para>
        /// </summary>
        public bool? AllowCollaboration
        {
            get
            {
                return this._allowCollaboration;
            }
            set
            {
                this._allowCollaboration = value;
            }
        }

        /// <summary>
        ///   <para>Deprecated, see allow_collaboration.</para>
        /// </summary>
        public bool? AllowMaintainerToPush
        {
            get
            {
                return this._allowMaintainerToPush;
            }
            set
            {
                this._allowMaintainerToPush = value;
            }
        }

        /// <summary>
        ///   <para>Assignee user ID.</para>
        /// </summary>
        public UserRef? AssigneeId
        {
            get
            {
                return this._assigneeId;
            }
            set
            {
                this._assigneeId = value;
            }
        }

        /// <summary>
        ///   <para>Description of MR. Limited to 1,048,576 characters.</para>
        /// </summary>
        public string? Description
        {
            get
            {
                return this._description;
            }
            set
            {
                this._description = value;
            }
        }

        /// <summary>
        ///   <para>The ID or URL-encoded path of the project owned by the authenticated user</para>
        /// </summary>
        public ProjectIdOrPathRef? Id
        {
            get
            {
                return this._id;
            }
            set
            {
                this._id = value;
            }
        }

        /// <summary>
        ///   <para>Flag indicating if a merge request should remove the source branch when merging.</para>
        /// </summary>
        public bool? RemoveSourceBranch
        {
            get
            {
                return this._removeSourceBranch;
            }
            set
            {
                this._removeSourceBranch = value;
            }
        }

        /// <summary>
        ///   <para>The source branch.</para>
        /// </summary>
        public string? SourceBranch
        {
            get
            {
                return this._sourceBranch;
            }
            set
            {
                this._sourceBranch = value;
            }
        }

        /// <summary>
        ///   <para>Squash commits into a single commit when merging.</para>
        /// </summary>
        public bool? Squash
        {
            get
            {
                return this._squash;
            }
            set
            {
                this._squash = value;
            }
        }

        /// <summary>
        ///   <para>The target branch.</para>
        /// </summary>
        public string? TargetBranch
        {
            get
            {
                return this._targetBranch;
            }
            set
            {
                this._targetBranch = value;
            }
        }

        /// <summary>
        ///   <para>The target project (numeric ID).</para>
        /// </summary>
        public ProjectIdRef? TargetProjectId
        {
            get
            {
                return this._targetProjectId;
            }
            set
            {
                this._targetProjectId = value;
            }
        }

        /// <summary>
        ///   <para>Title of MR.</para>
        /// </summary>
        public string? Title
        {
            get
            {
                return this._title;
            }
            set
            {
                this._title = value;
            }
        }
    }
}
