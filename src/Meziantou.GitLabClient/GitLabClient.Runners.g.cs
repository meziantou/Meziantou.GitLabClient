// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated
// </auto-generated>
// ------------------------------------------------------------------------------
#nullable enable
namespace Meziantou.GitLab
{
    public partial interface IGitLabClient
    {
        Meziantou.GitLab.IGitLabRunnersClient Runners
        {
            get;
        }
    }

    public partial interface IGitLabRunnersClient
    {
        /// <summary>
        ///   <para>URL: <c>POST /runners</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/runners.html#register-a-new-runner" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<RunnerRegistered> RegisterAsync(Meziantou.GitLab.RegisterRunnerRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
    }

    public partial class GitLabClient : Meziantou.GitLab.IGitLabRunnersClient
    {
        /// <summary>
        ///   <para>URL: <c>POST /runners</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/runners.html#register-a-new-runner" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        System.Threading.Tasks.Task<RunnerRegistered> Meziantou.GitLab.IGitLabRunnersClient.RegisterAsync(Meziantou.GitLab.RegisterRunnerRequest request, Meziantou.GitLab.RequestOptions? requestOptions, System.Threading.CancellationToken cancellationToken)
        {
            return this.Runners_RegisterAsync(request, requestOptions, cancellationToken);
        }

        public Meziantou.GitLab.IGitLabRunnersClient Runners
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        ///   <para>URL: <c>POST /runners</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/runners.html#register-a-new-runner" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        private async System.Threading.Tasks.Task<RunnerRegistered> Runners_RegisterAsync(Meziantou.GitLab.RegisterRunnerRequest request, Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            string url = Meziantou.GitLab.GitLabClient.Runners_RegisterAsync_BuildUrl();
            using (System.Net.Http.HttpRequestMessage requestMessage = new System.Net.Http.HttpRequestMessage())
            {
                requestMessage.Method = System.Net.Http.HttpMethod.Post;
                requestMessage.RequestUri = new System.Uri(url, System.UriKind.RelativeOrAbsolute);
                requestMessage.Content = new Meziantou.GitLab.Internals.JsonContent(request, Meziantou.GitLab.Serialization.JsonSerialization.Options);
                HttpResponse? response = null;
                try
                {
                    response = await this.SendAsync(requestMessage, requestOptions, cancellationToken).ConfigureAwait(false);
                    await response.EnsureStatusCodeAsync(cancellationToken).ConfigureAwait(false);
                    RunnerRegistered? result = await response.ToObjectAsync<RunnerRegistered>(cancellationToken).ConfigureAwait(false);
                    if ((result == null))
                    {
                        throw new Meziantou.GitLab.GitLabException(response.RequestMethod, response.RequestUri, response.StatusCode, "The response cannot be converted to 'RunnerRegistered' because the body is null or empty");
                    }

                    return result;
                }
                finally
                {
                    if ((response != null))
                    {
                        response.Dispose();
                    }
                }
            }
        }

        private static string Runners_RegisterAsync_BuildUrl()
        {
            string url;
            url = "runners";
            return url;
        }
    }

    public static partial class GitLabClientExtensions
    {
        /// <summary>
        ///   <para>URL: <c>POST /runners</c></para>
        ///   <para>
        ///     <seealso href="https://docs.gitlab.com/ee/api/runners.html#register-a-new-runner" />
        ///   </para>
        /// </summary>
        /// <param name="requestOptions">Options of the request</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation</param>
        public static System.Threading.Tasks.Task<RunnerRegistered> RegisterAsync(this Meziantou.GitLab.IGitLabRunnersClient client, string token, string? description = default(string?), bool? active = default(bool?), bool? locked = default(bool?), bool? runUntagged = default(bool?), System.Collections.Generic.IEnumerable<string>? tagList = default(System.Collections.Generic.IEnumerable<string>?), RunnerAccessLevel? accessLevel = default(RunnerAccessLevel?), int? maximumTimeout = default(int?), Meziantou.GitLab.RequestOptions? requestOptions = default(Meziantou.GitLab.RequestOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Meziantou.GitLab.RegisterRunnerRequest request = new Meziantou.GitLab.RegisterRunnerRequest(token);
            request.Description = description;
            request.Active = active;
            request.Locked = locked;
            request.RunUntagged = runUntagged;
            request.TagList = tagList;
            request.AccessLevel = accessLevel;
            request.MaximumTimeout = maximumTimeout;
            return client.RegisterAsync(request, requestOptions, cancellationToken);
        }
    }

    public partial class RegisterRunnerRequest
    {
        private RunnerAccessLevel? _accessLevel;

        private bool? _active;

        private string? _description;

        private bool? _locked;

        private int? _maximumTimeout;

        private bool? _runUntagged;

        private System.Collections.Generic.IEnumerable<string>? _tagList;

        private string? _token;

        /// <param name="token">Registration token.</param>
        public RegisterRunnerRequest(string? token)
        {
            this._token = token;
        }

        public RegisterRunnerRequest()
        {
        }

        /// <summary>
        ///   <para>The access_level of the runner; not_protected or ref_protected</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("access_level")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public RunnerAccessLevel? AccessLevel
        {
            get
            {
                return this._accessLevel;
            }
            set
            {
                this._accessLevel = value;
            }
        }

        /// <summary>
        ///   <para>Whether the runner is active</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("active")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? Active
        {
            get
            {
                return this._active;
            }
            set
            {
                this._active = value;
            }
        }

        /// <summary>
        ///   <para>Runner’s description</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("description")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public string? Description
        {
            get
            {
                return this._description;
            }
            set
            {
                this._description = value;
            }
        }

        /// <summary>
        ///   <para>Whether the runner should be locked for current project</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("locked")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? Locked
        {
            get
            {
                return this._locked;
            }
            set
            {
                this._locked = value;
            }
        }

        /// <summary>
        ///   <para>Maximum timeout set when this runner handles the job</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("maximum_timeout")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public int? MaximumTimeout
        {
            get
            {
                return this._maximumTimeout;
            }
            set
            {
                this._maximumTimeout = value;
            }
        }

        /// <summary>
        ///   <para>Whether the runner should handle untagged jobs</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("run_untagged")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public bool? RunUntagged
        {
            get
            {
                return this._runUntagged;
            }
            set
            {
                this._runUntagged = value;
            }
        }

        /// <summary>
        ///   <para>List of runner’s tags</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("tag_list")]
        [System.Text.Json.Serialization.JsonIgnoreAttribute(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull)]
        public System.Collections.Generic.IEnumerable<string>? TagList
        {
            get
            {
                return this._tagList;
            }
            set
            {
                this._tagList = value;
            }
        }

        /// <summary>
        ///   <para>Registration token.</para>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyNameAttribute("token")]
        public string? Token
        {
            get
            {
                return this._token;
            }
            set
            {
                this._token = value;
            }
        }
    }
}
