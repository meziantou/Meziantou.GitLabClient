using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;
using Meziantou.Framework;
using Meziantou.Framework.CodeDom;

namespace Meziantou.GitLabClient.Generator
{
    internal sealed partial class GitLabClientGenerator
    {
        private const string RootNamespace = "Meziantou.GitLab";
        private const string SerializationNamespace = "Meziantou.GitLab.Serialization";
        private static readonly FullPath s_rootPath = FullPath.FromPath("../../../../Meziantou.GitLabClient");

        internal static class WellKnownTypes
        {
            public static TypeReference UrlBuilderTypeReference { get; } = new TypeReference(RootNamespace + ".UrlBuilder");
            public static TypeReference PageOptionsTypeReference { get; } = new TypeReference(RootNamespace + ".PageOptions");
            public static TypeReference SkipUtcDateValidationAttributeTypeReference { get; } = new TypeReference(RootNamespace + ".SkipUtcDateValidationAttribute");
            public static TypeReference MappedPropertyAttributeTypeReference { get; } = new TypeReference(RootNamespace + ".MappedPropertyAttribute");
            public static TypeReference IGitLabObjectReferenceTypeReference { get; } = new TypeReference(RootNamespace + ".IGitLabObjectReference");
            public static TypeReference GitLabObjectInt64ReferenceJsonConverterTypeReference { get; } = new TypeReference(SerializationNamespace + ".GitLabObjectInt64ReferenceJsonConverter");
            public static TypeReference GitLabObjectStringReferenceJsonConverterTypeReference { get; } = new TypeReference(SerializationNamespace + ".GitLabObjectStringReferenceJsonConverter");
            public static TypeReference GitLabObjectObjectReferenceJsonConverterTypeReference { get; } = new TypeReference(SerializationNamespace + ".GitLabObjectObjectReferenceJsonConverter");
        }

        private readonly List<CompilationUnit> _units = new List<CompilationUnit>();

        internal Project Project { get; set; } = new Project();

        public void Generate()
        {
            CreateModel();
            GenerateCode();
            WriteFiles();
        }

        private void WriteFiles()
        {
            var existingFiles = Directory.GetFiles(s_rootPath, "*.g.cs", SearchOption.AllDirectories).Select(FullPath.FromPath).ToList();

            foreach (var unit in _units)
            {
                var relativePath = (string)unit.Data["FileName"];
                new DefaultFormatterVisitor().Visit(unit);
                var destinationFile = s_rootPath / relativePath;
                using var tw = new StreamWriter(destinationFile);
                new CSharpCodeGenerator().Write(tw, unit);

                existingFiles.Remove(destinationFile);
            }

            foreach (var file in existingFiles)
            {
                File.Delete(file);
            }
        }

        private CompilationUnit CreateUnit(string relativePath)
        {
            var extension = Path.GetExtension(relativePath);
            relativePath = Path.ChangeExtension(relativePath, ".g" + extension);

            var unit = new CompilationUnit
            {
                NullableContext = NullableContext.Enable,
            };
            unit.SetData("FileName", relativePath);

            unit.CommentsBefore.Add("------------------------------------------------------------------------------");
            unit.CommentsBefore.Add("<auto-generated>");
            unit.CommentsBefore.Add("    This code was generated by a tool.");
            unit.CommentsBefore.Add("");
            unit.CommentsBefore.Add("    Changes to this file may cause incorrect behavior and will be lost if");
            unit.CommentsBefore.Add("    the code is regenerated");
            unit.CommentsBefore.Add("</auto-generated>");
            unit.CommentsBefore.Add("------------------------------------------------------------------------------");

            _units.Add(unit);
            return unit;
        }

        private void GenerateCode()
        {
            // Generate types
            foreach (var model in Project.Models.OfType<Enumeration>().OrderBy(m => m.Name))
            {
                GenerateEnumeration(model);
            }

            foreach (var model in Project.Models.OfType<Entity>().OrderBy(m => m.Name))
            {
                GenerateEntity(model);
            }

            foreach (var entity in Project.ParameterEntities.OrderBy(p => p.Name))
            {
                GenerateParameterEntities(entity);
            }

            // Generate methods
            foreach (var methodGroup in Project.MethodGroups)
            {
                var groupUnit = CreateUnit("GitLabClient." + methodGroup.Name + ".cs");
                var groupNs = groupUnit.AddNamespace(RootNamespace);

                var clientInterface = groupNs.AddType(new InterfaceDeclaration("IGitLabClient") { Modifiers = Modifiers.Public | Modifiers.Partial });
                var groupClientInterface = groupNs.AddType(new InterfaceDeclaration("IGitLab" + methodGroup.Name + "Client") { Modifiers = Modifiers.Public | Modifiers.Partial });

                var groupClientClass = groupNs.AddType(new ClassDeclaration("GitLabClient")
                {
                    Modifiers = Modifiers.Partial,
                    Implements = { groupClientInterface },
                });

                // Property
                clientInterface.AddMember(new PropertyDeclaration(methodGroup.Name, groupClientInterface)
                {
                    Getter = new PropertyAccessorDeclaration() { Statements = null },
                });

                groupClientClass.AddMember(new PropertyDeclaration(methodGroup.Name, groupClientInterface)
                {
                    Modifiers = Modifiers.Public,
                    Getter = new PropertyAccessorDeclaration()
                    {
                        Statements = { new ReturnStatement(new ThisExpression()) },
                    },
                });

                // Extension methods
                var clientExtensionsClass = groupNs.AddType(new ClassDeclaration("GitLabClientExtensions")
                {
                    Modifiers = Modifiers.Partial | Modifiers.Public | Modifiers.Static,
                });

                // Methods
                foreach (var method in methodGroup.Methods)
                {
                    var requestType = CreateMethodArgumentType(groupNs, method);
                    GenerateInterfaceMethod(groupClientInterface, method, requestType);
                    GenerateExplicitImplementationMethod(groupClientClass, groupClientInterface, method, requestType);
                    GenerateMethod(groupClientClass, method, requestType);
                    GenerateMandatoryParameterExtensions(clientExtensionsClass, method, groupClientInterface, requestType);
                }

                //TODO GenerateFileExtensionMethod(groupClientClass, clientExtensionsClass);
                if (clientExtensionsClass.Members.Count == 0)
                {
                    groupNs.Types.Remove(clientExtensionsClass);
                }
            }
        }

        private static void AddDocumentationComments(CodeObject commentable, Documentation documentation)
        {
            if (documentation != null)
            {
                if (commentable is MethodArgumentDeclaration arg)
                {
                    var method = arg.GetSelfOrParentOfType<MethodDeclaration>();
                    if (documentation.Summary != null)
                    {
                        method.XmlComments.AddParam(arg.Name, documentation.Summary);
                    }
                }
                else if (commentable is IXmlCommentable xmlCommentable)
                {
                    if (documentation.Summary != null)
                    {
                        xmlCommentable.XmlComments.AddSummary(documentation.Summary);
                    }

                    if (documentation.Remark != null)
                    {
                        xmlCommentable.XmlComments.Add(new XElement("remark", documentation.Remark));
                    }

                    if (documentation.Returns != null)
                    {
                        xmlCommentable.XmlComments.AddReturn(documentation.Returns);
                    }
                }
            }
        }

        private static MethodDeclaration GenerateInterfaceMethod(InterfaceDeclaration clientInterface, Method method, TypeReference requestType)
        {
            var m = clientInterface.AddMember(new MethodDeclaration(GetMethodName(method)));
            GenerateMethodSignature(method, m, requestType, out _, out _, out _);
            return m;
        }

        private static string GetMethodName(Method method)
        {
            var result = method.Name;
            if (method.MethodType != MethodType.GetPaged)
            {
                result += "Async";
            }

            return result;
        }

        private static MethodDeclaration GenerateExplicitImplementationMethod(ClassDeclaration clientClass, InterfaceDeclaration clientInterface, Method method, TypeReference requestType)
        {
            var m = clientClass.AddMember(new MethodDeclaration(GetMethodName(method)));
            m.PrivateImplementationType = clientInterface;
            GenerateMethodSignature(method, m, requestType, out _, out _, out _);
            foreach (var arg in m.Arguments)
            {
                arg.DefaultValue = null;
            }

            m.Statements = new ReturnStatement(
                new MethodInvokeExpression(
                    new MemberReferenceExpression(new ThisExpression(), method.MethodGroup.Name + '_' + m.Name),
                    m.Arguments.Select(arg => new ArgumentReferenceExpression(arg)).ToArray()));
            return m;
        }

        private static MethodDeclaration GenerateMethod(ClassDeclaration clientClass, Method method, TypeReference requestType)
        {
            var m = clientClass.AddMember(new MethodDeclaration(method.MethodGroup.Name + '_' + GetMethodName(method)));
            m.SetData("Method", method);
            GenerateMethodSignature(method, m, requestType, out var requestArgument, out var requestOptionsArgument, out var cancellationTokenArgument);
            m.Modifiers = Modifiers.Private;

            // Method body
            m.Statements = new StatementCollection();

            var urlBuilder = new VariableDeclarationStatement(
                WellKnownTypes.UrlBuilderTypeReference, "urlBuilder",
                new TypeReferenceExpression(WellKnownTypes.UrlBuilderTypeReference).CreateInvokeMethodExpression("Get", method.UrlTemplate));
            m.Statements.Add(urlBuilder);

            foreach (var param in method.Parameters.Where(p => GetParameterLocation(method, p) == ParameterLocation.Url))
            {
                if (param.Type.IsParameterEntity)
                {
                    var propertyName = param.Type.ParameterEntity.FinalType == ModelRef.Object ? "ValueAsString" : "Value";
                    if (param.Type.IsNullable)
                    {
                        var hasValueCondition = new ConditionStatement
                        {
                            Condition = CreatePropertyReference().CreateMemberReferenceExpression(nameof(Nullable<int>.HasValue)),
                            TrueStatements = urlBuilder
                                .CreateInvokeMethodExpression(
                                    "SetValue",
                                    param.Name,
                                    CreatePropertyReference().CreateMemberReferenceExpression(nameof(Nullable<int>.Value), propertyName)),
                        };
                        m.Statements.Add(hasValueCondition);
                    }
                    else
                    {
                        m.Statements.Add(urlBuilder.CreateInvokeMethodExpression("SetValue", param.Name, CreatePropertyReference().CreateMemberReferenceExpression(propertyName)));
                    }
                }
                else
                {
                    m.Statements.Add(urlBuilder.CreateInvokeMethodExpression("SetValue", param.Name, CreatePropertyReference()));
                }

                MemberReferenceExpression CreatePropertyReference()
                {
                    return requestArgument.CreateMemberReferenceExpression(ToPropertyName(param.Name));
                }
            }

            var url = new VariableDeclarationStatement(typeof(string), "url", urlBuilder.CreateInvokeMethodExpression("Build"));
            m.Statements.Add(url);

            var bodyArgument = CreateBodyArgument(method, m);
            switch (method.MethodType)
            {
                case MethodType.Get:
                    m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("GetAsync", new TypeReference[] { method.ReturnType }, url, requestOptionsArgument, cancellationTokenArgument)));
                    break;

                case MethodType.GetCollection:
                    m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("GetCollectionAsync", new TypeReference[] { method.ReturnType }, url, requestOptionsArgument, cancellationTokenArgument)));
                    break;

                case MethodType.GetPaged:
                    m.Statements.Add(new ReturnStatement(new NewObjectExpression(m.ReturnType!.Clone(), new ThisExpression(), url, requestOptionsArgument)));
                    break;

                case MethodType.Put:
                    var putArgs = new List<Expression>
                    {
                        url,
                        (Expression)bodyArgument ?? new LiteralExpression(value: null),
                        requestOptionsArgument,
                        cancellationTokenArgument!,
                    };
                    m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("PutJsonAsync", new TypeReference[] { method.ReturnType }, putArgs.ToArray())));
                    break;

                case MethodType.Post:
                    var postArgs = new List<Expression>
                    {
                        url,
                        (Expression)bodyArgument ?? new LiteralExpression(value: null),
                        requestOptionsArgument,
                        cancellationTokenArgument!,
                    };
                    if (method.ReturnType != null)
                    {
                        m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("PostJsonAsync", new TypeReference[] { method.ReturnType }, postArgs.ToArray())));
                    }
                    else
                    {
                        m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("PostJsonAsync", postArgs.ToArray())));
                    }
                    break;

                case MethodType.Delete:
                    m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("DeleteAsync", url, requestOptionsArgument, cancellationTokenArgument)));
                    break;

                default:
                    throw new NotSupportedException($"Method {method.MethodType} is not supported");
            }

            return m;
        }

        private static void GenerateMethodSignature(Method method, MethodDeclaration m, TypeReference requestType, out MethodArgumentDeclaration requestDataArgument, out MethodArgumentDeclaration requestOptionsArgument, out MethodArgumentDeclaration cancellationTokenArgument)
        {
            AddDocumentationComments(m, method.Documentation);

            if (method.MethodType == MethodType.GetPaged)
            {
                m.ReturnType = new TypeReference("Meziantou.GitLab.PagedResponse").MakeGeneric(method.ReturnType);
            }
            else
            {
                if (method.ReturnType != null)
                {
                    if (method.MethodType == MethodType.GetCollection || method.ReturnType.IsCollection)
                    {
                        m.ReturnType = new TypeReference(typeof(Task<>)).MakeGeneric(new TypeReference(typeof(IReadOnlyList<>)).MakeGeneric(method.ReturnType));
                    }
                    else
                    {
                        if (method.MethodType == MethodType.Get)
                        {
                            m.ReturnType = new TypeReference(typeof(Task<>)).MakeGeneric(method.ReturnType.ToTypeReference().MakeNullable());
                        }
                        else
                        {
                            m.ReturnType = new TypeReference(typeof(Task<>)).MakeGeneric(method.ReturnType.ToTypeReference());
                        }
                    }
                }
                else
                {
                    m.ReturnType = new TypeReference(typeof(Task));
                }
            }

            requestDataArgument = m.AddArgument(new MethodArgumentDeclaration(requestType, "request"));

            requestOptionsArgument = m.AddArgument(new MethodArgumentDeclaration(ModelRef.RequestOptions.ToTypeReference().MakeNullable(), "requestOptions") { DefaultValue = new DefaultValueExpression(ModelRef.RequestOptions) });
            AddDocumentationComments(requestOptionsArgument, new Documentation()
            {
                Summary = "Options of the request",
            });

            if (method.MethodType != MethodType.GetPaged)
            {
                cancellationTokenArgument = m.AddArgument(new MethodArgumentDeclaration(typeof(CancellationToken), "cancellationToken") { DefaultValue = new DefaultValueExpression(typeof(CancellationToken)) });
                AddDocumentationComments(cancellationTokenArgument, new Documentation()
                {
                    Summary = "A cancellation token that can be used by other objects or threads to receive notice of cancellation",
                });
            }
            else
            {
                cancellationTokenArgument = null;
            }
        }

        private static ClassDeclaration CreateMethodArgumentType(NamespaceDeclaration namespaceDeclaration, Method method)
        {
            var name = (method.RequestTypeName ?? (method.Name + method.MethodGroup.Name)) + "Request";
            var type = namespaceDeclaration.AddType(new ClassDeclaration(name));
            type.Modifiers = Modifiers.Public | Modifiers.Partial;

            var ctor = type.AddMember(new ConstructorDeclaration());
            ctor.Modifiers = Modifiers.Public;

            // properties
            foreach (var param in method.Parameters)
            {
                var paramType = GetArgumentTypeRef(param);
                if (!param.IsRequired)
                {
                    paramType = paramType.MakeNullable();
                }

                // field
                var field = type.AddMember(new FieldDeclaration(ToFieldName(param.Name), paramType));
                field.Modifiers = Modifiers.Private;

                // property getter/setter
                var property = type.AddMember(new PropertyDeclaration(ToPropertyName(param.Name), paramType));
                property.Modifiers = Modifiers.Public;
                property.Getter = new PropertyAccessorDeclaration(new ReturnStatement(field));
                property.Setter = new PropertyAccessorDeclaration(new AssignStatement(field, new ArgumentReferenceExpression("value")));

                // ctor required properties
                if (param.IsRequired)
                {
                    var argument = new MethodArgumentDeclaration(paramType, ToArgumentName(param.Name));
                    ctor.Arguments.Add(argument);
                    ctor.Statements.Add(new AssignStatement(field, argument));
                }
            }

            return type;
        }

        private static VariableReferenceExpression CreateBodyArgument(Method method, MethodDeclaration methodDeclaration)
        {
            var bodyArguments = method.Parameters.Where(p => GetParameterLocation(method, p) == ParameterLocation.Body).ToList();
            if (bodyArguments.Count == 0)
                return null;

            var variable = new VariableDeclarationStatement(typeof(Dictionary<string, object>), "body");
            methodDeclaration.Statements.Add(variable);
            variable.InitExpression = new NewObjectExpression(typeof(Dictionary<string, object>));
            foreach (var arg in bodyArguments)
            {
                Expression CreateArgumentReference() => new ArgumentReferenceExpression("request").CreateMemberReferenceExpression(ToPropertyName(arg.Name));

                var assign = variable.CreateInvokeMethodExpression(nameof(Dictionary<string, object>.Add), arg.Name, CreateArgumentReference());
                if (!arg.IsRequired)
                {
                    var condition = new ConditionStatement
                    {
                        Condition = new BinaryExpression(BinaryOperator.NotEquals, CreateArgumentReference(), new LiteralExpression(value: null)),
                        TrueStatements = assign,
                    };
                    methodDeclaration.Statements.Add(condition);
                }
                else
                {
                    methodDeclaration.Statements.Add(assign);
                }
            }

            return variable;
        }

        private static void GenerateMandatoryParameterExtensions(ClassDeclaration extensionClass, Method method, TypeReference interfaceReference, TypeReference requestType)
        {
            if (!new[] { MethodType.Get, MethodType.GetCollection, MethodType.GetPaged }.Contains(method.MethodType))
                return;

            var m = extensionClass.AddMember(new MethodDeclaration(GetMethodName(method)));
            GenerateMethodSignature(method, m, requestType, out var requestArgument, out var requestOptionsArgument, out var cancellationTokenArgument);
            m.Modifiers = Modifiers.Public | Modifiers.Static;
            var clientArgument = new MethodArgumentDeclaration(interfaceReference, "client") { IsExtension = true };
            m.Arguments.Remove(requestArgument);
            m.Arguments.Insert(0, clientArgument);
            m.Statements = new StatementCollection();

            var ctor = new NewObjectExpression(requestType);
            var requestVariable = new VariableDeclarationStatement(requestType, "request", initExpression: ctor);
            var requiredParameters = method.Parameters.Where(p => p.IsRequired).ToList();
            var parameterIndex = 1;
            foreach (var param in requiredParameters)
            {
                var paramArgument = new MethodArgumentDeclaration(GetArgumentTypeRef(param), ToArgumentName(param.Name));
                m.Arguments.Insert(parameterIndex, paramArgument);

                ctor.Arguments.Add(paramArgument);

                parameterIndex++;
            }

            var invokeArguments = new List<MethodInvokeArgumentExpression> { requestArgument };
            for (var i = parameterIndex; i < m.Arguments.Count; i++)
            {
                invokeArguments.Add(m.Arguments[i]);
            }

            m.Statements.Add(requestVariable);
            m.Statements.Add(new ReturnStatement(
                new MethodInvokeExpression(
                    new MemberReferenceExpression(clientArgument, m.Name),
                    invokeArguments.ToArray())));
        }

        //private static void GenerateExtensionMethod(ClassDeclaration extensionClass, Method method, MethodParameter methodParameter)
        //{
        //    foreach (var parameterEntityRef in methodParameter.Type.ParameterEntity.Refs.Where(r => r.ModelRef.IsModel))
        //    {
        //        var m = GenerateMethod(extensionClass, method);
        //        m.Modifiers |= Modifiers.Static;
        //        var extensionArgument = new MethodArgumentDeclaration(parameterEntityRef.ModelRef, ToArgumentName(parameterEntityRef.ModelRef.Model.Name)) { IsExtension = true };

        //        m.Statements.Clear();

        //        var invoke = new MethodInvokeExpression(new CastExpression(extensionArgument, new TypeReference("IGitLabObject")).CreateMemberReferenceExpression("GitLabClient", m.Name));

        //        foreach (var arg in m.Arguments.ToList())
        //        {
        //            if (arg.Data.TryGetValue("Parameter", out var parameter) && methodParameter == parameter)
        //            {
        //                m.Arguments.Remove(arg);
        //                invoke.Arguments.Add(extensionArgument);
        //            }
        //            else
        //            {
        //                invoke.Arguments.Add(arg);
        //            }
        //        }

        //        m.Statements.Add(new ReturnStatement(invoke));

        //        m.Name = m.Name.Replace(extensionClass.Name, "", StringComparison.OrdinalIgnoreCase);
        //        m.Arguments.Insert(0, extensionArgument);
        //    }
        //}

        //private static void GenerateFileExtensionMethod(ClassDeclaration classDeclaration, ClassDeclaration extensionClass)
        //{
        //    var methods = classDeclaration.Members
        //        .OfType<MethodDeclaration>()
        //        .Where(ContainsFileArgument)
        //        .ToList();

        //    foreach (var methodDeclaration in methods)
        //    {
        //        if (methodDeclaration.Data["Method"] is not Method method)
        //            continue;

        //        var m = GenerateMethod(extensionClass, method);
        //        m.Modifiers |= Modifiers.Static;

        //        Debug.Assert(m.Statements != null);
        //        m.Statements.Clear();

        //        var extensionArgument = new MethodArgumentDeclaration(new TypeReference("IGitLabClient"), "client") { IsExtension = true };

        //        var invoke = new MethodInvokeExpression(extensionArgument.CreateMemberReferenceExpression(methodDeclaration.Name!));

        //        foreach (var arg in m.Arguments.ToList())
        //        {
        //            if (arg.Name == "encoding")
        //            {
        //                invoke.Arguments.Add(new LiteralExpression("base64"));
        //                m.Arguments.Remove(arg);
        //            }
        //            else if (arg.Name == "content")
        //            {
        //                invoke.Arguments.Add(new TypeReferenceExpression(typeof(Convert)).CreateInvokeMethodExpression(nameof(Convert.ToBase64String), arg));
        //                arg.Type = typeof(byte[]);
        //            }
        //            else
        //            {
        //                invoke.Arguments.Add(arg);
        //            }
        //        }

        //        m.Statements.Add(new ReturnStatement(invoke));

        //        m.Name = m.Name.Replace(extensionClass.Name, "", StringComparison.OrdinalIgnoreCase);
        //        m.Arguments.Insert(0, extensionArgument);
        //    }

        //    static bool ContainsFileArgument(MethodDeclaration m)
        //    {
        //        return m.Arguments.Any(a => a.Name == "content" && a.Type.ClrFullTypeName == typeof(string).FullName) &&
        //               m.Arguments.Any(a => a.Name == "encoding" && a.Type.ClrFullTypeName == typeof(string).FullName);
        //    }
        //}

        private void GenerateEntity(Entity entity)
        {
            var unit = CreateUnit("Models/" + entity.Name + ".cs");
            var ns = unit.AddNamespace(RootNamespace);

            var type = ns.AddType(new ClassDeclaration(entity.Name));
            AddDocumentationComments(type, entity.Documentation);
            type.Modifiers = Modifiers.Public | Modifiers.Partial;
            type.BaseType = entity.BaseType ?? ModelRef.GitLabObject;

            GenerateJsonConverter();

            // Add default constructor
            var ctor = type.AddMember(new ConstructorDeclaration()
            {
                Arguments =
                {
                    new MethodArgumentDeclaration(typeof(JsonElement), "obj"),
                },
                Modifiers = Modifiers.Internal,
                Initializer = new ConstructorBaseInitializer(new ArgumentReferenceExpression("obj")),
            });

            // Add properties
            foreach (var prop in entity.Properties)
            {
                var propertyType = GetPropertyTypeRef(prop.Type);

                var propertyMember = type.AddMember(new PropertyDeclaration(ToPropertyName(prop.Name), propertyType)
                {
                    Modifiers = Modifiers.Public,
                });

                if (prop.Type.IsNullable)
                {
                    propertyMember.Getter = new StatementCollection
                    {
                        new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("GetValueOrDefault",
                        new TypeReference[]
                        {
                            GetPropertyTypeRef(prop.Type),
                        },
                        new Expression[]
                        {
                            prop.Name,
                            new DefaultValueExpression(GetPropertyTypeRef(prop.Type)),
                        })),
                    };
                }
                else
                {
                    propertyMember.Getter = new StatementCollection
                    {
                        new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("GetRequiredNonNullValue",
                        new TypeReference[]
                        {
                            GetPropertyTypeRef(prop.Type),
                        },
                        new Expression[]
                        {
                            prop.Name,
                        })),
                    };
                }

                AddDocumentationComments(propertyMember, prop.Documentation);

                if (prop.Type == ModelRef.Date || prop.Type == ModelRef.NullableDate)
                {
                    propertyMember.CustomAttributes.Add(new CustomAttribute(WellKnownTypes.SkipUtcDateValidationAttributeTypeReference) { Arguments = { new CustomAttributeArgument("Does not contain time nor timezone (e.g. 2018-01-01)") } });
                }

                propertyMember.CustomAttributes.Add(new CustomAttribute(WellKnownTypes.MappedPropertyAttributeTypeReference) { Arguments = { new CustomAttributeArgument(prop.Name) } });
            }

            // Generate Equals members (Equals, GetHashCode, ==, !=, IEquatable<T>)
            var displayProperty = entity.Properties.FirstOrDefault(p => p.IsDisplayName);
            var keyProperties = entity.Properties.Where(p => p.IsKey).ToList();
            if (keyProperties.Count > 0)
            {
                type.Implements.Add(new TypeReference(typeof(IEquatable<>)).MakeGeneric(type));

                GenerateEqualMethod();
                GenerateEqualTypedMethod();
                GenerateGetHashCode();
                GenerateEqualityOperator();
            }

            // Generate EntityDisplayName (DebuggerDisplay, ToString)
            if (displayProperty != null)
            {
                GenerateDebuggerDisplay();
            }

            void GenerateEqualMethod()
            {
                var equal = type.AddMember(new MethodDeclaration(nameof(object.Equals)));
                equal.Modifiers = Modifiers.Public | Modifiers.Override;
                equal.ReturnType = typeof(bool);
                var objArg = equal.AddArgument("obj", new TypeReference(typeof(object)).MakeNullable());
                var statements = new StatementCollection();
                equal.Statements = statements;

                statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("Equals", new ConvertExpression(objArg, type))));
            }

            void GenerateEqualTypedMethod()
            {
                var equal = type.AddMember(new MethodDeclaration(nameof(object.Equals)));
                equal.Modifiers = Modifiers.Public | Modifiers.Virtual;
                equal.ReturnType = typeof(bool);
                var objArg = equal.AddArgument("obj", new TypeReference(type).MakeNullable());

                Expression returnExpression = new UnaryExpression(
                    UnaryOperator.Not,
                    new MethodInvokeExpression(
                        new MemberReferenceExpression(typeof(object), nameof(object.ReferenceEquals)),
                        objArg,
                        LiteralExpression.Null()));

                foreach (var key in keyProperties)
                {
                    var typeRef = GetPropertyTypeRef(key.Type);
                    var expr = new BinaryExpression(BinaryOperator.Equals,
                        new ThisExpression().CreateMemberReferenceExpression(ToPropertyName(key.Name)),
                        objArg.CreateMemberReferenceExpression(ToPropertyName(key.Name)));

                    returnExpression = new BinaryExpression(BinaryOperator.And, returnExpression, expr);
                }

                equal.Statements = new ReturnStatement(returnExpression);
            }

            void GenerateGetHashCode()
            {
                var equal = type.AddMember(new MethodDeclaration(nameof(object.GetHashCode)));
                equal.Modifiers = Modifiers.Public | Modifiers.Override;
                equal.ReturnType = typeof(int);

                var statements = new StatementCollection();
                var expressions = new List<Expression>();

                foreach (var key in keyProperties)
                {
                    expressions.Add(new ThisExpression().CreateMemberReferenceExpression(ToPropertyName(key.Name)));
                }

                statements.Add(new ReturnStatement(
                    new MethodInvokeExpression(
                        new MemberReferenceExpression(new TypeReferenceExpression(typeof(HashCode)), nameof(HashCode.Combine)),
                        expressions.ToArray())));

                equal.Statements = statements;
            }

            void GenerateEqualityOperator()
            {
                var equal = type.AddMember(new OperatorDeclaration("=="));
                equal.Modifiers = Modifiers.Public | Modifiers.Static;
                equal.ReturnType = typeof(bool);
                equal.Arguments.Add(new MethodArgumentDeclaration(new TypeReference(type).MakeNullable(), "a"));
                equal.Arguments.Add(new MethodArgumentDeclaration(new TypeReference(type).MakeNullable(), "b"));
                equal.Statements.Add(new ReturnStatement(new TypeReferenceExpression(new TypeReference(typeof(EqualityComparer<>)).MakeGeneric(type)).CreateMemberReferenceExpression("Default").CreateInvokeMethodExpression("Equals",
                    new ArgumentReferenceExpression("a"),
                    new ArgumentReferenceExpression("b"))));

                var notEqual = type.AddMember(new OperatorDeclaration("!="));
                notEqual.Modifiers = Modifiers.Public | Modifiers.Static;
                notEqual.ReturnType = typeof(bool);
                notEqual.Arguments.Add(new MethodArgumentDeclaration(new TypeReference(type).MakeNullable(), "a"));
                notEqual.Arguments.Add(new MethodArgumentDeclaration(new TypeReference(type).MakeNullable(), "b"));
                notEqual.Statements.Add(new ReturnStatement(new UnaryExpression(UnaryOperator.Not, new BinaryExpression(BinaryOperator.Equals, new ArgumentReferenceExpression("a"), new ArgumentReferenceExpression("b")))));
            }

            void GenerateDebuggerDisplay()
            {
                var properties = new[] { displayProperty }.Concat(keyProperties).Where(p => p != null);

                type.CustomAttributes.Add(new CustomAttribute(typeof(DebuggerDisplayAttribute))
                {
                    Arguments =
                    {
                        new CustomAttributeArgument(new LiteralExpression("{GetType().Name,nq} " + string.Join(", ", properties.Select(v=>$"{ToPropertyName(v.Name)}={{{ToPropertyName(v.Name)}}}")))),
                    },
                });
            }

            void GenerateJsonConverter()
            {
                var ns = unit.AddNamespace(SerializationNamespace);
                var converterType = ns.AddType(new ClassDeclaration(entity.Name + "JsonConverter"));
                converterType.BaseType = new TypeReference("Meziantou.GitLab.Serialization.GitLabObjectBaseJsonConverter").MakeGeneric(type);
                converterType.Modifiers = Modifiers.Partial | Modifiers.Sealed | Modifiers.Internal;

                var createInstanceMethod = converterType.AddMember(new MethodDeclaration("CreateInstance"));
                createInstanceMethod.Modifiers = Modifiers.Protected | Modifiers.Override;
                createInstanceMethod.ReturnType = type;
                var objArg = createInstanceMethod.AddArgument("jsonElement", typeof(JsonElement));
                createInstanceMethod.Statements = new StatementCollection
                {
                    new ReturnStatement(new NewObjectExpression(type, objArg)),
                };

                type.CustomAttributes.Add(new CustomAttribute(typeof(JsonConverterAttribute))
                {
                    Arguments = { new CustomAttributeArgument(new TypeOfExpression(converterType)) },
                });
            }
        }

        private void GenerateEnumeration(Enumeration enumeration)
        {
            var unit = CreateUnit("Models/" + enumeration.Name + ".cs");
            var ns = unit.AddNamespace(RootNamespace);
            var enumType = ns.AddType(new EnumerationDeclaration(enumeration.Name));
            AddDocumentationComments(enumType, enumeration.Documentation);
            enumType.Modifiers = Modifiers.Public;
            enumType.BaseType = enumeration.BaseType;

            if (enumeration.IsFlags)
            {
                enumType.CustomAttributes.Add(new CustomAttribute(typeof(FlagsAttribute)));
            }

            if (enumeration.SerializeAsString)
            {
                var converterType = GenerateJsonConverter();
                enumType.CustomAttributes.Add(new CustomAttribute(typeof(JsonConverterAttribute))
                {
                    Arguments = { new CustomAttributeArgument(new TypeOfExpression(converterType)) },
                });

                GenerateUrlBuilder();
            }

            foreach (var member in enumeration.Members)
            {
                var enumerationMember = new Framework.CodeDom.EnumerationMember(ToPropertyName(member.Name));
                if (member.Value != null)
                {
                    enumerationMember.Value = new LiteralExpression(member.Value);
                }

                if (enumeration.SerializeAsString)
                {
                    enumerationMember.CustomAttributes.Add(new CustomAttribute(typeof(EnumMemberAttribute))
                    {
                        Arguments = { new CustomAttributeArgument(nameof(EnumMemberAttribute.Value), member.SerializationName ?? member.Name) },
                    });
                }

                AddDocumentationComments(enumerationMember, member.Documentation);
                enumType.Members.Add(enumerationMember);
            }

            if (enumeration.GenerateAllMember)
            {
                Expression initExpression = null;
                foreach (var member in enumType.Members)
                {
                    Expression memberExpression = new TypeReferenceExpression(enumType).CreateMemberReferenceExpression(member.Name);
                    if (initExpression == null)
                    {
                        initExpression = memberExpression;
                    }
                    else
                    {
                        initExpression = new BinaryExpression(BinaryOperator.BitwiseOr, initExpression, memberExpression);
                    }
                }

                var enumerationMember = new Framework.CodeDom.EnumerationMember(ToPropertyName("all"), initExpression);
                enumType.Members.Add(enumerationMember);
            }

            TypeDeclaration GenerateJsonConverter()
            {
                var serializationNamespace = unit.AddNamespace(SerializationNamespace);

                // EnumMembers
                var enumMember = serializationNamespace.AddType(new ClassDeclaration("EnumMember"));
                enumMember.Modifiers = Modifiers.Partial;

                var enumMemberType = new TypeReference("Meziantou.GitLab.Serialization.EnumMember").MakeGeneric(enumType);
                var arrayType = enumMemberType.Clone();
                arrayType.ArrayRank = 1;

                // EnumMember.Field
                var initArray = enumMember.AddMember(new MethodDeclaration("Create" + enumeration.Name + "Members"));
                initArray.Modifiers = Modifiers.Private | Modifiers.Static;
                initArray.ReturnType = arrayType;
                initArray.Statements = new StatementCollection();
                var result = new VariableDeclarationStatement(arrayType, "result", new NewArrayExpression(enumMemberType, enumeration.Members.Count));
                initArray.Statements.Add(result);

                for (var i = 0; i < enumeration.Members.Count; i++)
                {
                    var enumerationMember = enumeration.Members[i];
                    initArray.Statements.Add(new AssignStatement(
                        new ArrayIndexerExpression(result, i),
                        new NewObjectExpression(enumMemberType, new MemberReferenceExpression(new TypeReferenceExpression(enumType), ToPropertyName(enumerationMember.Name)), enumerationMember.SerializationName ?? enumerationMember.Name)));
                }
                initArray.Statements.Add(new ReturnStatement(result));

                var membersField = enumMember.AddMember(new FieldDeclaration("s_" + enumeration.Name + "members", arrayType));
                membersField.Modifiers = Modifiers.Private | Modifiers.Static | Modifiers.ReadOnly;
                membersField.InitExpression = new MethodInvokeExpression(new MemberReferenceExpression(new TypeReferenceExpression(enumMember), initArray));

                // EnumMember.FromString
                var fromString = enumMember.AddMember(new MethodDeclaration(enumeration.Name + "FromString"));
                var fromStringArg = fromString.AddArgument("value", typeof(string));
                fromString.Modifiers = Modifiers.Public | Modifiers.Static;
                fromString.ReturnType = enumType;
                fromString.Statements = new StatementCollection
                {
                    new ReturnStatement(new MethodInvokeExpression(
                        new MemberReferenceExpression(new TypeReferenceExpression(enumMember), "FromString"),
                        fromStringArg,
                        new MemberReferenceExpression(new TypeReferenceExpression(enumMember), membersField))),
                };

                // EnumMember.ToString
                var toString = enumMember.AddMember(new MethodDeclaration("ToString"));
                var toStringArg = toString.AddArgument("value", enumType);
                toString.Modifiers = Modifiers.Public | Modifiers.Static;
                toString.ReturnType = typeof(string);
                toString.Statements = new StatementCollection();
                foreach (var member in enumeration.Members)
                {
                    toString.Statements.Add(new ConditionStatement()
                    {
                        Condition = new BinaryExpression(BinaryOperator.Equals, toStringArg, new MemberReferenceExpression(new TypeReferenceExpression(enumType), ToPropertyName(member.Name))),
                        TrueStatements = new ReturnStatement(member.SerializationName ?? member.Name),
                    });
                }

                toString.Statements.Add(new ThrowStatement(
                    new NewObjectExpression(typeof(ArgumentOutOfRangeException),
                        new NameofExpression(toStringArg),
                        new MethodInvokeExpression(new MemberReferenceExpression(typeof(string), "Concat"), "Value '", new MethodInvokeExpression(new MemberReferenceExpression(toStringArg, "ToString")), "' is not valid"))));

                // Json converter
                var converterType = serializationNamespace.AddType(new ClassDeclaration(enumeration.Name + "JsonConverter"));
                converterType.BaseType = new TypeReference("Meziantou.GitLab.Serialization.EnumBaseJsonConverter").MakeGeneric(enumType);
                converterType.Modifiers = Modifiers.Partial | Modifiers.Sealed | Modifiers.Internal;

                // ToString
                var converterToString = converterType.AddMember(new MethodDeclaration("ToString"));
                converterToString.Modifiers = Modifiers.Protected | Modifiers.Override;
                converterToString.ReturnType = typeof(string);
                var convertToStringArg = converterToString.AddArgument("value", enumType);
                converterToString.Statements =
                    new ReturnStatement(
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(new TypeReferenceExpression(enumMember), "ToString"),
                            convertToStringArg));

                // FromString
                var converterFromString = converterType.AddMember(new MethodDeclaration("FromString"));
                converterFromString.Modifiers = Modifiers.Protected | Modifiers.Override;
                converterFromString.ReturnType = enumType;
                var convertFromStringArg = converterFromString.AddArgument("value", typeof(string));
                converterFromString.Statements =
                    new ReturnStatement(
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(new TypeReferenceExpression(enumMember), enumeration.Name + "FromString"),
                            convertFromStringArg));

                return converterType;
            }

            void GenerateUrlBuilder()
            {
                var urlBuilder = ns.AddType(new ClassDeclaration("UrlBuilder"));
                urlBuilder.Modifiers = Modifiers.Partial;

                // nullable
                {
                    var setValueNullable = urlBuilder.AddMember(new MethodDeclaration("SetValue"));
                    var keyArg = setValueNullable.AddArgument("key", typeof(string));
                    var valueArg = setValueNullable.AddArgument("value", new TypeReference(enumType).MakeNullable());
                    setValueNullable.Modifiers = Modifiers.Public;
                    setValueNullable.Statements = new StatementCollection()
                    {
                        new ConditionStatement
                        {
                            Condition = new MemberReferenceExpression(valueArg, "HasValue"),
                            TrueStatements = new StatementCollection()
                            {
                                new MethodInvokeExpression(new MemberReferenceExpression(new ThisExpression(), "SetValue"), keyArg,
                                    new MethodInvokeExpression(new MemberReferenceExpression(valueArg, "GetValueOrDefault"))),
                            },
                            FalseStatements = new StatementCollection()
                            {
                                new MethodInvokeExpression(new MemberReferenceExpression(new ThisExpression(), "SetNullValue"), keyArg),
                            },
                        },
                    };
                }

                // not nullable
                {
                    var setValue = urlBuilder.AddMember(new MethodDeclaration("SetValue"));
                    var keyArg = setValue.AddArgument("key", typeof(string));
                    var valueArg = setValue.AddArgument("value", new TypeReference(enumType));
                    setValue.Modifiers = Modifiers.Public;
                    setValue.Statements = new StatementCollection();
                    // _parameters[key] = value;
                    var parameterReference =
                        new ArrayIndexerExpression(
                            new MemberReferenceExpression(new ThisExpression(), "_parameters"),
                            keyArg);

                    var stringValue = new MethodInvokeExpression(
                        new MemberReferenceExpression(new TypeReference(SerializationNamespace + ".EnumMember"), "ToString"),
                        valueArg);

                    setValue.Statements.Add(new AssignStatement(parameterReference, stringValue));
                }
            }
        }

        private void GenerateParameterEntities(ParameterEntity entity)
        {
            var unit = CreateUnit("Models/" + entity.Name + ".cs");
            var ns = unit.AddNamespace(RootNamespace);
            var type = ns.AddType(new StructDeclaration(entity.Name));
            type.Modifiers = Modifiers.Public | Modifiers.ReadOnly | Modifiers.Partial;

            type.Implements.Add(WellKnownTypes.IGitLabObjectReferenceTypeReference.MakeGeneric(entity.FinalType));
            var converterType = entity.FinalType == ModelRef.NumberId ? WellKnownTypes.GitLabObjectInt64ReferenceJsonConverterTypeReference :
                                entity.FinalType == ModelRef.String ? WellKnownTypes.GitLabObjectStringReferenceJsonConverterTypeReference :
                                entity.FinalType == ModelRef.Object ? WellKnownTypes.GitLabObjectObjectReferenceJsonConverterTypeReference :
                                throw new ArgumentException($"Type '{entity.FinalType}' is not supported", nameof(entity));
            type.CustomAttributes.Add(new CustomAttribute(typeof(JsonConverterAttribute))
            {
                Arguments =
                {
                    new CustomAttributeArgument(new TypeOfExpression(converterType)),
                },
            });

            // Add Value Property (readonly)
            var valueField = new FieldDeclaration("_value", GetPropertyTypeRef(entity.FinalType), Modifiers.Private | Modifiers.ReadOnly);
            var valueProperty = new PropertyDeclaration("Value", GetPropertyTypeRef(entity.FinalType))
            {
                Modifiers = Modifiers.Public,
                Getter = new PropertyAccessorDeclaration
                {
                    Statements = new ReturnStatement(valueField),
                },
            };

            type.AddMember(valueField);
            type.AddMember(valueProperty);

            foreach (var entityRef in entity.Refs)
            {
                var addNullCheck = entityRef.ModelRef.Model != null;

                // Add constructor
                var ctor = type.AddMember(new ConstructorDeclaration()
                {
                    Modifiers = Modifiers.Private,
                    Arguments =
                    {
                        new MethodArgumentDeclaration(GetPropertyTypeRef(entityRef.ModelRef), entityRef.Name),
                    },
                    Statements =
                    {
                        new AssignStatement(valueField, GetAssignExpression()),
                    },
                });

                if (addNullCheck)
                {
                    ctor.Statements.Insert(0, ctor.Arguments[0].CreateThrowIfNullStatement());
                }

                // FromXXX
                var fromMethod = type.AddMember(new MethodDeclaration()
                {
                    Name = "From" + ToPropertyName(entityRef.Name),
                    Modifiers = Modifiers.Public | Modifiers.Static,
                    ReturnType = type,
                    Arguments =
                    {
                         new MethodArgumentDeclaration(GetPropertyTypeRef(entityRef.ModelRef), entityRef.Name),
                    },
                    Statements = new ReturnStatement(new NewObjectExpression(type, new ArgumentReferenceExpression(entityRef.Name))),
                });

                if (addNullCheck)
                {
                    fromMethod.Statements.Insert(0, fromMethod.Arguments[0].CreateThrowIfNullStatement());
                }

                // Add implicit converter
                type.AddMember(new OperatorDeclaration
                {
                    Modifiers = Modifiers.Public | Modifiers.Static | Modifiers.Implicit,
                    ReturnType = type,
                    Arguments =
                    {
                         new MethodArgumentDeclaration(GetPropertyTypeRef(entityRef.ModelRef), entityRef.Name),
                    },
                    Statements =
                    {
                        new ReturnStatement(new MethodInvokeExpression(new MemberReferenceExpression(type, fromMethod.Name), new ArgumentReferenceExpression(entityRef.Name))),
                    },
                });

                Expression GetAssignExpression()
                {
                    Expression value = new ArgumentReferenceExpression(entityRef.Name);
                    foreach (var member in entityRef.PropertyPath)
                    {
                        value = value.CreateMemberReferenceExpression(ToPropertyName(member));
                    }

                    return value;
                }
            }

            // ToString
            var toString = type.AddMember(new MethodDeclaration("ToString"));
            toString.ReturnType = typeof(string);
            toString.Modifiers = Modifiers.Public | Modifiers.Override;
            toString.Statements = new ReturnStatement(new MethodInvokeExpression(new MemberReferenceExpression(valueProperty, "ToString")));

            if (entity.FinalType == ModelRef.Object)
            {
                toString.ReturnType = toString.ReturnType.MakeNullable();
            }
        }

        private static string ToFieldName(string value)
        {
            var pascalCase = ToPropertyName(value);
            return "_" + char.ToLowerInvariant(pascalCase[0]) + pascalCase[1..];
        }

        private static string ToPropertyName(string value)
        {
            return value.Split(new[] { "_" }, StringSplitOptions.RemoveEmptyEntries)
             .Select(s => char.ToUpperInvariant(s[0]) + s[1..])
             .Aggregate(string.Empty, (s1, s2) => s1 + s2);
        }

        private static string ToArgumentName(string value)
        {
            var pascalCase = ToPropertyName(value);
            return char.ToLowerInvariant(pascalCase[0]) + pascalCase[1..];
        }

        private static ParameterLocation GetParameterLocation(Method method, MethodParameter parameter)
        {
            if (parameter.Location != ParameterLocation.Default)
            {
                return parameter.Location;
            }

            if (method.UrlTemplate.Contains($":{parameter.Name}/", StringComparison.Ordinal) || method.UrlTemplate.EndsWith($":{parameter.Name}", StringComparison.Ordinal))
                return ParameterLocation.Url;

            return method.MethodType switch
            {
                MethodType.Get or MethodType.GetPaged => ParameterLocation.Url,
                MethodType.Put or MethodType.Post or MethodType.Delete => ParameterLocation.Body,
                _ => throw new ArgumentOutOfRangeException(nameof(method)),
            };
        }

        private static TypeReference GetPropertyTypeRef(ModelRef modelRef)
        {
            var typeRef = (TypeReference)modelRef;
            if (modelRef.IsCollection)
            {
                typeRef = new TypeReference(typeof(IReadOnlyList<>)).MakeGeneric(typeRef);
            }

            return typeRef;
        }

        private static TypeReference GetArgumentTypeRef(MethodParameter param)
        {
            var typeRef = (TypeReference)param.Type;
            if (param.Type.IsCollection)
            {
                typeRef = new TypeReference(typeof(IEnumerable<>)).MakeGeneric(typeRef);
            }

            if (!param.IsRequired)
            {
                typeRef = typeRef.MakeNullable();
            }

            return typeRef;
        }
    }
}
