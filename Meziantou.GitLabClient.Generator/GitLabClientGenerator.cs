using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;
using Meziantou.Framework;
using Meziantou.Framework.CodeDom;
using Meziantou.GitLab;
using Meziantou.GitLab.Serialization;

namespace Meziantou.GitLabClient.Generator
{
    internal sealed partial class GitLabClientGenerator
    {
        private const string RootNamespace = "Meziantou.GitLab";
        private const string SerializationNamespace = "Meziantou.GitLab.Serialization";
        private static readonly FullPath s_rootPath = FullPath.FromPath("../../../../Meziantou.GitLabClient");

        private readonly List<CompilationUnit> _units = new List<CompilationUnit>();

        internal Project Project { get; set; } = new Project();

        public void Generate()
        {
            CreateModel();
            GenerateCode();
            DeleteGeneratedFiles();
            WriteFiles();
        }

        private void WriteFiles()
        {
            foreach (var unit in _units)
            {
                WriteFile(unit);
            }
        }

        private static void DeleteGeneratedFiles()
        {
            var files = Directory.GetFiles(s_rootPath, "*.g.cs", SearchOption.AllDirectories);
            foreach (var file in files)
            {
                File.Delete(file);
            }
        }

        private static void WriteFile(CompilationUnit unit)
        {
            var relativePath = (string)unit.Data["FileName"];
            new DefaultFormatterVisitor().Visit(unit);
            var destinationFile = s_rootPath / relativePath;
            using var tw = new StreamWriter(destinationFile);
            new CSharpCodeGenerator().Write(tw, unit);
        }

        private CompilationUnit CreateUnit(string relativePath)
        {
            var extension = Path.GetExtension(relativePath);
            relativePath = Path.ChangeExtension(relativePath, ".g" + extension);

            var unit = new CompilationUnit
            {
                NullableContext = NullableContext.Enable,
            };
            unit.SetData("FileName", relativePath);

            unit.CommentsBefore.Add("------------------------------------------------------------------------------");
            unit.CommentsBefore.Add("<auto-generated>");
            unit.CommentsBefore.Add("    This code was generated by a tool.");
            unit.CommentsBefore.Add("");
            unit.CommentsBefore.Add("    Changes to this file may cause incorrect behavior and will be lost if");
            unit.CommentsBefore.Add("    the code is regenerated");
            unit.CommentsBefore.Add("</auto-generated>");
            unit.CommentsBefore.Add("------------------------------------------------------------------------------");

            _units.Add(unit);
            return unit;
        }

        private void GenerateCode()
        {
            // Generate types
            foreach (var model in Project.Models.OfType<Enumeration>().OrderBy(m => m.Name))
            {
                GenerateEnumeration(model);
            }

            foreach (var model in Project.Models.OfType<Entity>().OrderBy(m => m.Name))
            {
                GenerateEntity(model);
            }

            foreach (var entity in Project.ParameterEntities.OrderBy(p => p.Name))
            {
                GenerateParameterEntities(entity);
            }

            // Generate methods
            foreach (var methodGroup in Project.MethodGroups)
            {
                var groupUnit = CreateUnit("GitLabClient." + methodGroup.Name + ".cs");
                var groupNs = groupUnit.AddNamespace(RootNamespace);

                var clientInterface = groupNs.AddType(new InterfaceDeclaration("IGitLabClient") { Modifiers = Modifiers.Public | Modifiers.Partial });
                var groupClientInterface = groupNs.AddType(new InterfaceDeclaration("IGitLab" + methodGroup.Name + "Client") { Modifiers = Modifiers.Public | Modifiers.Partial });

                var groupClientClass = groupNs.AddType(new ClassDeclaration("GitLabClient")
                {
                    Modifiers = Modifiers.Partial,
                    Implements = { groupClientInterface },
                });

                // Property
                clientInterface.AddMember(new PropertyDeclaration(methodGroup.Name, groupClientInterface)
                {
                    Getter = new PropertyAccessorDeclaration() { Statements = null },
                });

                groupClientClass.AddMember(new PropertyDeclaration(methodGroup.Name, groupClientInterface)
                {
                    Modifiers = Modifiers.Public,
                    Getter = new PropertyAccessorDeclaration()
                    {
                        Statements = { new ReturnStatement(new ThisExpression()) },
                    },
                });

                // Methods
                foreach (var method in methodGroup.Methods)
                {
                    GenerateInterfaceMethod(groupClientInterface, method);
                    GenerateExplicitImplementationMethod(groupClientClass, groupClientInterface, method);
                    GenerateMethod(groupClientClass, method);
                }

                // Extension methods
                var clientExtensionsClass = groupNs.AddType(new ClassDeclaration("GitLabClientExtensions")
                {
                    Modifiers = Modifiers.Partial | Modifiers.Public | Modifiers.Static,
                });

                GenerateFileExtensionMethod(groupClientClass, clientExtensionsClass);
                if (clientExtensionsClass.Members.Count == 0)
                {
                    groupNs.Types.Remove(clientExtensionsClass);
                }

                // Write file
                WriteFile(groupUnit);
            }
        }

        private static void AddDocumentationComments(CodeObject commentable, Documentation documentation)
        {
            if (documentation != null)
            {
                if (commentable is MethodArgumentDeclaration arg)
                {
                    var method = arg.GetSelfOrParentOfType<MethodDeclaration>();
                    if (documentation.Summary != null)
                    {
                        method.XmlComments.AddParam(arg.Name, documentation.Summary);
                    }
                }
                else if (commentable is IXmlCommentable xmlCommentable)
                {
                    if (documentation.Summary != null)
                    {
                        xmlCommentable.XmlComments.AddSummary(documentation.Summary);
                    }

                    if (documentation.Remark != null)
                    {
                        xmlCommentable.XmlComments.Add(new XElement("remark", documentation.Remark));
                    }

                    if (documentation.Returns != null)
                    {
                        xmlCommentable.XmlComments.AddReturn(documentation.Returns);
                    }
                }
            }
        }

        private static MethodDeclaration GenerateInterfaceMethod(InterfaceDeclaration clientInterface, Method method)
        {
            var m = clientInterface.AddMember(new MethodDeclaration(method.Name + "Async"));
            GenerateMethodSignature(method, m, out _, out _, out _, out _);
            return m;
        }

        private static MethodDeclaration GenerateExplicitImplementationMethod(ClassDeclaration clientClass, InterfaceDeclaration clientInterface, Method method)
        {
            var m = clientClass.AddMember(new MethodDeclaration(method.Name + "Async"));
            m.PrivateImplementationType = clientInterface;
            GenerateMethodSignature(method, m, out _, out _, out _, out _);
            foreach (var arg in m.Arguments)
            {
                arg.DefaultValue = null;
            }

            m.Statements = new ReturnStatement(
                new MethodInvokeExpression(
                    new MemberReferenceExpression(new ThisExpression(), method.MethodGroup.Name + '_' + m.Name),
                    m.Arguments.Select(arg => new ArgumentReferenceExpression(arg)).ToArray()));
            return m;
        }

        private static MethodDeclaration GenerateMethod(ClassDeclaration clientClass, Method method)
        {
            var m = clientClass.AddMember(new MethodDeclaration(method.MethodGroup.Name + '_' + method.Name + "Async"));
            m.SetData("Method", method);
            GenerateMethodSignature(method, m, out var arguments, out var pageArgument, out var requestOptionsArgument, out var cancellationTokenArgument);
            m.Modifiers = Modifiers.Private;

            // Method body
            m.Statements = new StatementCollection();

            var urlBuilder = new VariableDeclarationStatement(
                typeof(UrlBuilder), "urlBuilder",
                new TypeReferenceExpression(typeof(UrlBuilder)).CreateInvokeMethodExpression("Get", method.UrlTemplate));
            m.Statements.Add(urlBuilder);

            foreach (var param in method.Parameters.Where(p => GetParameterLocation(method, p) == ParameterLocation.Url))
            {
                if (param.Type.IsParameterEntity)
                {
                    if (param.Type.IsNullable)
                    {
                        var hasValueCondition = new ConditionStatement
                        {
                            Condition = arguments[param].CreateMemberReferenceExpression(nameof(Nullable<int>.HasValue)),
                            TrueStatements = urlBuilder.CreateInvokeMethodExpression(nameof(UrlBuilder.WithValue), param.Name, arguments[param].CreateMemberReferenceExpression(nameof(Nullable<int>.Value), "Value")),
                        };
                        m.Statements.Add(hasValueCondition);
                    }
                    else
                    {
                        m.Statements.Add(urlBuilder.CreateInvokeMethodExpression(nameof(UrlBuilder.WithValue), param.Name, arguments[param].CreateMemberReferenceExpression("Value")));
                    }
                }
                else
                {
                    m.Statements.Add(urlBuilder.CreateInvokeMethodExpression(nameof(UrlBuilder.WithValue), param.Name, arguments[param]));
                }
            }

            if (pageArgument != null)
            {
                var pageCondition = new ConditionStatement()
                {
                    Condition = new BinaryExpression(BinaryOperator.NotEquals, pageArgument, new LiteralExpression(value: null)),
                    TrueStatements = new StatementCollection
                    {
                        new ConditionStatement()
                        {
                            Condition = new BinaryExpression(BinaryOperator.GreaterThan, pageArgument.CreateMemberReferenceExpression(nameof(PageOptions.PageIndex)), new LiteralExpression(0)),
                            TrueStatements = new StatementCollection
                            {
                                urlBuilder.CreateInvokeMethodExpression(nameof(UrlBuilder.WithValue), "page", pageArgument.CreateMemberReferenceExpression(nameof(PageOptions.PageIndex))),
                            },
                        },
                        new ConditionStatement()
                        {
                            Condition = new BinaryExpression(BinaryOperator.GreaterThan, pageArgument.CreateMemberReferenceExpression(nameof(PageOptions.PageSize)), new LiteralExpression(0)),
                            TrueStatements = new StatementCollection
                            {
                                urlBuilder.CreateInvokeMethodExpression(nameof(UrlBuilder.WithValue), "per_page", pageArgument.CreateMemberReferenceExpression(nameof(PageOptions.PageSize))),
                            },
                        },
                        new ConditionStatement()
                        {
                            Condition = new BinaryExpression(BinaryOperator.Equals, pageArgument.CreateMemberReferenceExpression(nameof(PageOptions.OrderBy), nameof(OrderBy.Name)).CreateIsNullOrEmptyExpression(), new LiteralExpression(value: false)),
                            TrueStatements = new StatementCollection
                            {
                                urlBuilder.CreateInvokeMethodExpression(nameof(UrlBuilder.WithValue), "order_by", pageArgument.CreateMemberReferenceExpression(nameof(PageOptions.OrderBy), nameof(OrderBy.Name))),
                                urlBuilder.CreateInvokeMethodExpression(nameof(UrlBuilder.WithValue), "sort", pageArgument.CreateMemberReferenceExpression(nameof(PageOptions.OrderBy), nameof(OrderBy.Direction))),
                            },
                        },
                    },
                };

                m.Statements.Add(pageCondition);
            }

            var url = new VariableDeclarationStatement(typeof(string), "url", urlBuilder.CreateInvokeMethodExpression(nameof(UrlBuilder.Build)));
            m.Statements.Add(url);

            var bodyArgument = CreateBodyArgument(method, m);
            switch (method.MethodType)
            {
                case MethodType.Get:
                    m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("GetAsync", new TypeReference[] { method.ReturnType }, url, requestOptionsArgument, cancellationTokenArgument)));
                    break;

                case MethodType.GetCollection:
                    m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("GetCollectionAsync", new TypeReference[] { method.ReturnType }, url, requestOptionsArgument, cancellationTokenArgument)));
                    break;

                case MethodType.GetPaged:
                    m.Statements.Add(new ReturnStatement(new NewObjectExpression(m.ReturnType!.Clone(), new ThisExpression(), url, requestOptionsArgument)));
                    break;

                case MethodType.Put:
                    var putArgs = new List<Expression>
                    {
                        url,
                        (Expression)bodyArgument ?? new LiteralExpression(value: null),
                        requestOptionsArgument,
                        cancellationTokenArgument!,
                    };
                    m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("PutJsonAsync", new TypeReference[] { method.ReturnType }, putArgs.ToArray())));
                    break;

                case MethodType.Post:
                    var postArgs = new List<Expression>
                    {
                        url,
                        (Expression)bodyArgument ?? new LiteralExpression(value: null),
                        requestOptionsArgument,
                        cancellationTokenArgument!,
                    };
                    if (method.ReturnType != null)
                    {
                        m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("PostJsonAsync", new TypeReference[] { method.ReturnType }, postArgs.ToArray())));
                    }
                    else
                    {
                        m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("PostJsonAsync", postArgs.ToArray())));
                    }
                    break;

                case MethodType.Delete:
                    m.Statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("DeleteAsync", url, requestOptionsArgument, cancellationTokenArgument)));
                    break;

                default:
                    throw new NotSupportedException($"Method {method.MethodType} is not supported");
            }

            return m;
        }

        private static void GenerateMethodSignature(Method method, MethodDeclaration m, out Dictionary<MethodParameter, MethodArgumentDeclaration> arguments, out MethodArgumentDeclaration pageArgument, out MethodArgumentDeclaration requestOptionsArgument, out MethodArgumentDeclaration cancellationTokenArgument)
        {
            AddDocumentationComments(m, method.Documentation);

            if (method.MethodType == MethodType.GetPaged)
            {
                m.ReturnType = new TypeReference("Meziantou.GitLab.PagedResponse").MakeGeneric(method.ReturnType);
            }
            else
            {
                if (method.ReturnType != null)
                {
                    if (method.MethodType == MethodType.GetCollection || method.ReturnType.IsCollection)
                    {
                        m.ReturnType = new TypeReference(typeof(Task<>)).MakeGeneric(new TypeReference(typeof(IReadOnlyList<>)).MakeGeneric(method.ReturnType));
                    }
                    else
                    {
                        m.ReturnType = new TypeReference(typeof(Task<>)).MakeGeneric(method.ReturnType.ToTypeReference().MakeNullable());
                    }
                }
                else
                {
                    m.ReturnType = new TypeReference(typeof(Task));
                }
            }

            arguments = new Dictionary<MethodParameter, MethodArgumentDeclaration>();
            foreach (var param in method.Parameters.OrderBy(p => p.IsRequired ? -1 : 1))
            {
                var type = GetArgumentTypeRef(param);
                var argument = m.AddArgument(new MethodArgumentDeclaration(type, param.MethodParameterName ?? ToArgumentName(param.Name)));
                if (!param.IsRequired)
                {
                    argument.DefaultValue = new DefaultValueExpression(argument.Type.Clone());
                }

                arguments.Add(param, argument);
                argument.SetData("Parameter", param);
                AddDocumentationComments(argument, param.Documentation);
            }

            pageArgument = null;
            if (method.MethodType == MethodType.GetPaged)
            {
                pageArgument = m.AddArgument(new MethodArgumentDeclaration(new TypeReference(typeof(PageOptions)).MakeNullable(), "pageOptions")
                {
                    DefaultValue = new DefaultValueExpression(typeof(PageOptions)),
                });

                AddDocumentationComments(pageArgument, new Documentation()
                {
                    Summary = "The page index and page size",
                });
            }

            requestOptionsArgument = m.AddArgument(new MethodArgumentDeclaration(ModelRef.RequestOptions.ToTypeReference().MakeNullable(), "requestOptions") { DefaultValue = new DefaultValueExpression(ModelRef.RequestOptions) });
            AddDocumentationComments(requestOptionsArgument, new Documentation()
            {
                Summary = "Options of the request",
            });

            if (method.MethodType != MethodType.GetPaged)
            {
                cancellationTokenArgument = m.AddArgument(new MethodArgumentDeclaration(typeof(CancellationToken), "cancellationToken") { DefaultValue = new DefaultValueExpression(typeof(CancellationToken)) });
                AddDocumentationComments(cancellationTokenArgument, new Documentation()
                {
                    Summary = "A cancellation token that can be used by other objects or threads to receive notice of cancellation",
                });
            }
            else
            {
                cancellationTokenArgument = null;
            }
        }

        private static VariableReferenceExpression CreateBodyArgument(Method method, MethodDeclaration methodDeclaration)
        {
            var bodyArguments = method.Parameters.Where(p => GetParameterLocation(method, p) == ParameterLocation.Body).ToList();
            if (bodyArguments.Count == 0)
                return null;

            var variable = new VariableDeclarationStatement(typeof(Dictionary<string, object>), "body");
            methodDeclaration.Statements.Add(variable);
            variable.InitExpression = new NewObjectExpression(typeof(Dictionary<string, object>));
            foreach (var arg in bodyArguments)
            {
                var argumentReference = methodDeclaration.Arguments.First(a => a.Data["Parameter"] == arg);
                var assign = variable.CreateInvokeMethodExpression(nameof(Dictionary<string, object>.Add), arg.Name, argumentReference);
                if (!arg.IsRequired)
                {
                    var condition = new ConditionStatement
                    {
                        Condition = new BinaryExpression(BinaryOperator.NotEquals, argumentReference, new LiteralExpression(value: null)),
                        TrueStatements = assign,
                    };
                    methodDeclaration.Statements.Add(condition);
                }
                else
                {
                    methodDeclaration.Statements.Add(assign);
                }
            }

            return variable;
        }

        private static void GenerateExtensionMethod(ClassDeclaration extensionClass, Method method, MethodParameter methodParameter)
        {
            foreach (var parameterEntityRef in methodParameter.Type.ParameterEntity.Refs.Where(r => r.ModelRef.IsModel))
            {
                var m = GenerateMethod(extensionClass, method);
                m.Modifiers |= Modifiers.Static;
                var extensionArgument = new MethodArgumentDeclaration(parameterEntityRef.ModelRef, ToArgumentName(parameterEntityRef.ModelRef.Model.Name)) { IsExtension = true };

                m.Statements.Clear();

                var invoke = new MethodInvokeExpression(new CastExpression(extensionArgument, new TypeReference("IGitLabObject")).CreateMemberReferenceExpression("GitLabClient", m.Name));

                foreach (var arg in m.Arguments.ToList())
                {
                    if (arg.Data.TryGetValue("Parameter", out var parameter) && methodParameter == parameter)
                    {
                        m.Arguments.Remove(arg);
                        invoke.Arguments.Add(extensionArgument);
                    }
                    else
                    {
                        invoke.Arguments.Add(arg);
                    }
                }

                m.Statements.Add(new ReturnStatement(invoke));

                m.Name = m.Name.Replace(extensionClass.Name, "", StringComparison.OrdinalIgnoreCase);
                m.Arguments.Insert(0, extensionArgument);
            }
        }

        private static void GenerateFileExtensionMethod(ClassDeclaration classDeclaration, ClassDeclaration extensionClass)
        {
            var methods = classDeclaration.Members
                .OfType<MethodDeclaration>()
                .Where(ContainsFileArgument)
                .ToList();

            foreach (var methodDeclaration in methods)
            {
                if (methodDeclaration.Data["Method"] is not Method method)
                    continue;

                var m = GenerateMethod(extensionClass, method);
                m.Modifiers |= Modifiers.Static;

                Debug.Assert(m.Statements != null);
                m.Statements.Clear();

                var extensionArgument = new MethodArgumentDeclaration(new TypeReference("IGitLabClient"), "client") { IsExtension = true };

                var invoke = new MethodInvokeExpression(extensionArgument.CreateMemberReferenceExpression(methodDeclaration.Name!));

                foreach (var arg in m.Arguments.ToList())
                {
                    if (arg.Name == "encoding")
                    {
                        invoke.Arguments.Add(new LiteralExpression("base64"));
                        m.Arguments.Remove(arg);
                    }
                    else if (arg.Name == "content")
                    {
                        invoke.Arguments.Add(new TypeReferenceExpression(typeof(Convert)).CreateInvokeMethodExpression(nameof(Convert.ToBase64String), arg));
                        arg.Type = typeof(byte[]);
                    }
                    else
                    {
                        invoke.Arguments.Add(arg);
                    }
                }

                m.Statements.Add(new ReturnStatement(invoke));

                m.Name = m.Name.Replace(extensionClass.Name, "", StringComparison.OrdinalIgnoreCase);
                m.Arguments.Insert(0, extensionArgument);
            }

            static bool ContainsFileArgument(MethodDeclaration m)
            {
                return m.Arguments.Any(a => a.Name == "content" && a.Type.ClrFullTypeName == typeof(string).FullName) &&
                       m.Arguments.Any(a => a.Name == "encoding" && a.Type.ClrFullTypeName == typeof(string).FullName);
            }
        }

        private void GenerateEntity(Entity entity)
        {
            var unit = CreateUnit("Models/" + entity.Name + ".cs");
            var ns = unit.AddNamespace(RootNamespace);

            var type = ns.AddType(new ClassDeclaration(entity.Name));
            AddDocumentationComments(type, entity.Documentation);
            type.Modifiers = Modifiers.Public | Modifiers.Partial;
            type.BaseType = entity.BaseType ?? ModelRef.GitLabObject;

            GenerateJsonConverter();

            // Add default constructor
            var ctor = type.AddMember(new ConstructorDeclaration()
            {
                Arguments =
                {
                    new MethodArgumentDeclaration(typeof(JsonElement), "obj"),
                },
                Modifiers = Modifiers.Internal,
                Initializer = new ConstructorBaseInitializer(new ArgumentReferenceExpression("obj")),
            });

            // Add properties
            foreach (var prop in entity.Properties)
            {
                var propertyMember = type.AddMember(new PropertyDeclaration(ToPropertyName(prop.Name), GetPropertyTypeRef(prop.Type))
                {
                    Modifiers = Modifiers.Public,
                    Getter = new StatementCollection
                    {
                        new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("GetValueOrDefault",
                        new TypeReference[]
                        {
                            GetPropertyTypeRef(prop.Type),
                        },
                        new Expression[]
                        {
                            prop.Name,
                            new DefaultValueExpression(GetPropertyTypeRef(prop.Type)),
                        })),
                    },
                });

                AddDocumentationComments(propertyMember, prop.Documentation);

                if (prop.Type == ModelRef.Date || prop.Type == ModelRef.NullableDate)
                {
                    propertyMember.CustomAttributes.Add(new CustomAttribute(typeof(SkipUtcDateValidationAttribute)) { Arguments = { new CustomAttributeArgument("Does not contain time nor timezone (e.g. 2018-01-01)") } });
                }

                propertyMember.CustomAttributes.Add(new CustomAttribute(typeof(MappedPropertyAttribute)) { Arguments = { new CustomAttributeArgument(prop.Name) } });
            }

            // Generate Equals members (Equals, GetHashCode, ==, !=, IEquatable<T>)
            var displayProperty = entity.Properties.FirstOrDefault(p => p.IsDisplayName);
            var keyProperties = entity.Properties.Where(p => p.IsKey).ToList();
            if (keyProperties.Count > 0)
            {
                type.Implements.Add(new TypeReference(typeof(IEquatable<>)).MakeGeneric(type));

                GenerateEqualMethod();
                GenerateEqualTypedMethod();
                GenerateGetHashCode();
                GenerateEqualityOperator();
            }

            // Generate EntityDisplayName (DebuggerDisplay, ToString)
            if (displayProperty != null)
            {
                GenerateDebuggerDisplay();
            }

            void GenerateEqualMethod()
            {
                var equal = type.AddMember(new MethodDeclaration(nameof(object.Equals)));
                equal.Modifiers = Modifiers.Public | Modifiers.Override;
                equal.ReturnType = typeof(bool);
                var objArg = equal.AddArgument("obj", new TypeReference(typeof(object)).MakeNullable());
                var statements = new StatementCollection();
                equal.Statements = statements;

                statements.Add(new ReturnStatement(new ThisExpression().CreateInvokeMethodExpression("Equals", new ConvertExpression(objArg, type))));
            }

            void GenerateEqualTypedMethod()
            {
                var equal = type.AddMember(new MethodDeclaration(nameof(object.Equals)));
                equal.Modifiers = Modifiers.Public | Modifiers.Virtual;
                equal.ReturnType = typeof(bool);
                var objArg = equal.AddArgument("obj", new TypeReference(type).MakeNullable());

                Expression returnExpression = new UnaryExpression(
                    UnaryOperator.Not,
                    new MethodInvokeExpression(
                        new MemberReferenceExpression(typeof(object), nameof(object.ReferenceEquals)),
                        objArg,
                        LiteralExpression.Null()));

                foreach (var key in keyProperties)
                {
                    var typeRef = GetPropertyTypeRef(key.Type);
                    var expr = new BinaryExpression(BinaryOperator.Equals,
                        new ThisExpression().CreateMemberReferenceExpression(ToPropertyName(key.Name)),
                        objArg.CreateMemberReferenceExpression(ToPropertyName(key.Name)));

                    returnExpression = new BinaryExpression(BinaryOperator.And, returnExpression, expr);
                }

                equal.Statements = new ReturnStatement(returnExpression);
            }

            void GenerateGetHashCode()
            {
                var equal = type.AddMember(new MethodDeclaration(nameof(object.GetHashCode)));
                equal.Modifiers = Modifiers.Public | Modifiers.Override;
                equal.ReturnType = typeof(int);

                var statements = new StatementCollection();
                var expressions = new List<Expression>();

                foreach (var key in keyProperties)
                {
                    expressions.Add(new ThisExpression().CreateMemberReferenceExpression(ToPropertyName(key.Name)));
                }

                statements.Add(new ReturnStatement(
                    new MethodInvokeExpression(
                        new MemberReferenceExpression(new TypeReferenceExpression(typeof(HashCode)), nameof(HashCode.Combine)),
                        expressions.ToArray())));

                equal.Statements = statements;
            }

            void GenerateEqualityOperator()
            {
                var equal = type.AddMember(new OperatorDeclaration("=="));
                equal.Modifiers = Modifiers.Public | Modifiers.Static;
                equal.ReturnType = typeof(bool);
                equal.Arguments.Add(new MethodArgumentDeclaration(new TypeReference(type).MakeNullable(), "a"));
                equal.Arguments.Add(new MethodArgumentDeclaration(new TypeReference(type).MakeNullable(), "b"));
                equal.Statements.Add(new ReturnStatement(new TypeReferenceExpression(new TypeReference(typeof(EqualityComparer<>)).MakeGeneric(type)).CreateMemberReferenceExpression("Default").CreateInvokeMethodExpression("Equals",
                    new ArgumentReferenceExpression("a"),
                    new ArgumentReferenceExpression("b"))));

                var notEqual = type.AddMember(new OperatorDeclaration("!="));
                notEqual.Modifiers = Modifiers.Public | Modifiers.Static;
                notEqual.ReturnType = typeof(bool);
                notEqual.Arguments.Add(new MethodArgumentDeclaration(new TypeReference(type).MakeNullable(), "a"));
                notEqual.Arguments.Add(new MethodArgumentDeclaration(new TypeReference(type).MakeNullable(), "b"));
                notEqual.Statements.Add(new ReturnStatement(new UnaryExpression(UnaryOperator.Not, new BinaryExpression(BinaryOperator.Equals, new ArgumentReferenceExpression("a"), new ArgumentReferenceExpression("b")))));
            }

            void GenerateDebuggerDisplay()
            {
                var properties = new[] { displayProperty }.Concat(keyProperties).Where(p => p != null);

                type.CustomAttributes.Add(new CustomAttribute(typeof(DebuggerDisplayAttribute))
                {
                    Arguments =
                    {
                        new CustomAttributeArgument(new LiteralExpression("{GetType().Name,nq} " + string.Join(", ", properties.Select(v=>$"{ToPropertyName(v.Name)}={{{ToPropertyName(v.Name)}}}")))),
                    },
                });
            }

            void GenerateJsonConverter()
            {
                var ns = unit.AddNamespace(SerializationNamespace);
                var converterType = ns.AddType(new ClassDeclaration(entity.Name + "JsonConverter"));
                converterType.BaseType = new TypeReference("Meziantou.GitLab.Serialization.GitLabObjectBaseJsonConverter").MakeGeneric(type);
                converterType.Modifiers = Modifiers.Partial | Modifiers.Sealed | Modifiers.Internal;

                var createInstanceMethod = converterType.AddMember(new MethodDeclaration("CreateInstance"));
                createInstanceMethod.Modifiers = Modifiers.Protected | Modifiers.Override;
                createInstanceMethod.ReturnType = type;
                var objArg = createInstanceMethod.AddArgument("jsonElement", typeof(JsonElement));
                createInstanceMethod.Statements = new StatementCollection
                {
                    new ReturnStatement(new NewObjectExpression(type, objArg)),
                };

                type.CustomAttributes.Add(new CustomAttribute(typeof(JsonConverterAttribute))
                {
                    Arguments = { new CustomAttributeArgument(new TypeOfExpression(converterType)) },
                });
            }
        }

        private void GenerateEnumeration(Enumeration enumeration)
        {
            var unit = CreateUnit("Models/" + enumeration.Name + ".cs");
            var ns = unit.AddNamespace(RootNamespace);
            var enumType = ns.AddType(new EnumerationDeclaration(enumeration.Name));
            AddDocumentationComments(enumType, enumeration.Documentation);
            enumType.Modifiers = Modifiers.Public;
            enumType.BaseType = enumeration.BaseType;

            if (enumeration.IsFlags)
            {
                enumType.CustomAttributes.Add(new CustomAttribute(typeof(FlagsAttribute)));
            }

            if (enumeration.SerializeAsString)
            {
                var converterType = GenerateJsonConverter();
                enumType.CustomAttributes.Add(new CustomAttribute(typeof(JsonConverterAttribute))
                {
                    Arguments = { new CustomAttributeArgument(new TypeOfExpression(converterType)) },
                });
            }

            foreach (var member in enumeration.Members)
            {
                var enumerationMember = new Framework.CodeDom.EnumerationMember(ToPropertyName(member.Name));
                if (member.Value != null)
                {
                    enumerationMember.Value = new LiteralExpression(member.Value);
                }

                if (enumeration.SerializeAsString)
                {
                    enumerationMember.CustomAttributes.Add(new CustomAttribute(typeof(EnumMemberAttribute))
                    {
                        Arguments = { new CustomAttributeArgument(nameof(EnumMemberAttribute.Value), member.SerializationName ?? member.Name) },
                    });
                }

                AddDocumentationComments(enumerationMember, member.Documentation);
                enumType.Members.Add(enumerationMember);
            }

            if (enumeration.GenerateAllMember)
            {
                Expression initExpression = null;
                foreach (var member in enumType.Members)
                {
                    Expression memberExpression = new TypeReferenceExpression(enumType).CreateMemberReferenceExpression(member.Name);
                    if (initExpression == null)
                    {
                        initExpression = memberExpression;
                    }
                    else
                    {
                        initExpression = new BinaryExpression(BinaryOperator.BitwiseOr, initExpression, memberExpression);
                    }
                }

                var enumerationMember = new Framework.CodeDom.EnumerationMember(ToPropertyName("all"), initExpression);
                enumType.Members.Add(enumerationMember);
            }

            TypeDeclaration GenerateJsonConverter()
            {
                var serializationNamespace = unit.AddNamespace(SerializationNamespace);

                // EnumMembers
                var enumMember = serializationNamespace.AddType(new ClassDeclaration("EnumMember"));
                enumMember.Modifiers = Modifiers.Partial;

                var enumMemberType = new TypeReference("Meziantou.GitLab.Serialization.EnumMember").MakeGeneric(enumType);
                var arrayType = enumMemberType.Clone();
                arrayType.ArrayRank = 1;

                // EnumMember.Field
                var initArray = enumMember.AddMember(new MethodDeclaration("Create" + enumeration.Name + "Members"));
                initArray.Modifiers = Modifiers.Private | Modifiers.Static;
                initArray.ReturnType = arrayType;
                initArray.Statements = new StatementCollection();
                var result = new VariableDeclarationStatement(arrayType, "result", new NewArrayExpression(enumMemberType, enumeration.Members.Count));
                initArray.Statements.Add(result);

                for (var i = 0; i < enumeration.Members.Count; i++)
                {
                    var enumerationMember = enumeration.Members[i];
                    initArray.Statements.Add(new AssignStatement(
                        new ArrayIndexerExpression(result, i),
                        new NewObjectExpression(enumMemberType, new MemberReferenceExpression(new TypeReferenceExpression(enumType), ToPropertyName(enumerationMember.Name)), enumerationMember.SerializationName ?? enumerationMember.Name)));
                }
                initArray.Statements.Add(new ReturnStatement(result));

                var membersField = enumMember.AddMember(new FieldDeclaration("s_" + enumeration.Name + "members", arrayType));
                membersField.Modifiers = Modifiers.Private | Modifiers.Static | Modifiers.ReadOnly;
                membersField.InitExpression = new MethodInvokeExpression(new MemberReferenceExpression(new TypeReferenceExpression(enumMember), initArray));

                // EnumMember.FromString
                var fromString = enumMember.AddMember(new MethodDeclaration(enumeration.Name + "FromString"));
                var fromStringArg = fromString.AddArgument("value", typeof(string));
                fromString.Modifiers = Modifiers.Public | Modifiers.Static;
                fromString.ReturnType = enumType;
                fromString.Statements = new StatementCollection
                {
                    new ReturnStatement(new MethodInvokeExpression(
                        new MemberReferenceExpression(new TypeReferenceExpression(enumMember), "FromString"),
                        fromStringArg,
                        new MemberReferenceExpression(new TypeReferenceExpression(enumMember), membersField))),
                };

                // EnumMember.ToString
                var toString = enumMember.AddMember(new MethodDeclaration("ToString"));
                var toStringArg = toString.AddArgument("value", enumType);
                toString.Modifiers = Modifiers.Public | Modifiers.Static;
                toString.ReturnType = typeof(string);
                toString.Statements = new StatementCollection();
                foreach (var member in enumeration.Members)
                {
                    toString.Statements.Add(new ConditionStatement()
                    {
                        Condition = new BinaryExpression(BinaryOperator.Equals, toStringArg, new MemberReferenceExpression(new TypeReferenceExpression(enumType), ToPropertyName(member.Name))),
                        TrueStatements = new ReturnStatement(member.SerializationName ?? member.Name),
                    });
                }

                toString.Statements.Add(new ThrowStatement(new NewObjectExpression(typeof(ArgumentOutOfRangeException), new NameofExpression(toStringArg))));

                // Json converter
                var converterType = serializationNamespace.AddType(new ClassDeclaration(enumeration.Name + "JsonConverter"));
                converterType.BaseType = new TypeReference("Meziantou.GitLab.Serialization.EnumBaseJsonConverter").MakeGeneric(enumType);
                converterType.Modifiers = Modifiers.Partial | Modifiers.Sealed | Modifiers.Internal;

                // ToString
                var converterToString = converterType.AddMember(new MethodDeclaration("ToString"));
                converterToString.Modifiers = Modifiers.Protected | Modifiers.Override;
                converterToString.ReturnType = typeof(string);
                var convertToStringArg = converterToString.AddArgument("value", enumType);
                converterToString.Statements =
                    new ReturnStatement(
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(new TypeReferenceExpression(enumMember), "ToString"),
                            convertToStringArg));

                // FromString
                var converterFromString = converterType.AddMember(new MethodDeclaration("FromString"));
                converterFromString.Modifiers = Modifiers.Protected | Modifiers.Override;
                converterFromString.ReturnType = enumType;
                var convertFromStringArg = converterFromString.AddArgument("value", typeof(string));
                converterFromString.Statements =
                    new ReturnStatement(
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(new TypeReferenceExpression(enumMember), enumeration.Name + "FromString"),
                            convertFromStringArg));

                return converterType;
            }
        }

        private void GenerateParameterEntities(ParameterEntity entity)
        {
            var unit = CreateUnit("Models/" + entity.Name + ".cs");
            var ns = unit.AddNamespace(RootNamespace);
            var type = ns.AddType(new StructDeclaration(entity.Name));
            type.Modifiers = Modifiers.Public | Modifiers.ReadOnly | Modifiers.Partial;

            type.Implements.Add(new TypeReference(typeof(IGitLabObjectReference<>)).MakeGeneric(entity.FinalType));
            var converterType = entity.FinalType == ModelRef.NumberId ? typeof(GitLabObjectInt64ReferenceJsonConverter) :
                                entity.FinalType == ModelRef.String ? typeof(GitLabObjectStringReferenceJsonConverter) :
                                entity.FinalType == ModelRef.Object ? typeof(GitLabObjectObjectReferenceJsonConverter) :
                                throw new ArgumentException($"Type '{entity.FinalType}' is not supported", nameof(entity));
            type.CustomAttributes.Add(new CustomAttribute(typeof(JsonConverterAttribute))
            {
                Arguments =
                {
                    new CustomAttributeArgument(new TypeOfExpression(converterType)),
                },
            });

            // Add Value Property (readonly)
            var valueField = new FieldDeclaration("_value", GetPropertyTypeRef(entity.FinalType), Modifiers.Private | Modifiers.ReadOnly);
            var valueProperty = new PropertyDeclaration("Value", GetPropertyTypeRef(entity.FinalType))
            {
                Modifiers = Modifiers.Public,
                Getter = new PropertyAccessorDeclaration
                {
                    Statements = new ReturnStatement(valueField),
                },
            };

            type.AddMember(valueField);
            type.AddMember(valueProperty);

            foreach (var entityRef in entity.Refs)
            {
                var addNullCheck = entityRef.ModelRef.Model != null;

                // Add constructor
                var ctor = type.AddMember(new ConstructorDeclaration()
                {
                    Modifiers = Modifiers.Private,
                    Arguments =
                    {
                        new MethodArgumentDeclaration(GetPropertyTypeRef(entityRef.ModelRef), entityRef.Name),
                    },
                    Statements =
                    {
                        new AssignStatement(valueField, GetAssignExpression()),
                    },
                });

                if (addNullCheck)
                {
                    ctor.Statements.Insert(0, ctor.Arguments[0].CreateThrowIfNullStatement());
                }

                // FromXXX
                var fromMethod = type.AddMember(new MethodDeclaration()
                {
                    Name = "From" + entityRef.ModelRef.ShortTypeName,
                    Modifiers = Modifiers.Public | Modifiers.Static,
                    ReturnType = type,
                    Arguments =
                    {
                         new MethodArgumentDeclaration(GetPropertyTypeRef(entityRef.ModelRef), entityRef.Name),
                    },
                    Statements = new ReturnStatement(new NewObjectExpression(type, new ArgumentReferenceExpression(entityRef.Name))),
                });

                if (addNullCheck)
                {
                    fromMethod.Statements.Insert(0, fromMethod.Arguments[0].CreateThrowIfNullStatement());
                }

                // Add implicit converter
                type.AddMember(new OperatorDeclaration
                {
                    Modifiers = Modifiers.Public | Modifiers.Static | Modifiers.Implicit,
                    ReturnType = type,
                    Arguments =
                    {
                         new MethodArgumentDeclaration(GetPropertyTypeRef(entityRef.ModelRef), entityRef.Name),
                    },
                    Statements =
                    {
                        new ReturnStatement(new MethodInvokeExpression(new MemberReferenceExpression(type, fromMethod.Name), new ArgumentReferenceExpression(entityRef.Name))),
                    },
                });

                Expression GetAssignExpression()
                {
                    Expression value = new ArgumentReferenceExpression(entityRef.Name);
                    foreach (var member in entityRef.PropertyPath)
                    {
                        value = value.CreateMemberReferenceExpression(ToPropertyName(member));
                    }

                    return value;
                }
            }

            // ToString
            var toString = type.AddMember(new MethodDeclaration("ToString"));
            toString.ReturnType = typeof(string);
            toString.Modifiers = Modifiers.Public | Modifiers.Override;
            toString.Statements = new ReturnStatement(new MethodInvokeExpression(new MemberReferenceExpression(valueProperty, "ToString")));
        }

        private static string ToFieldName(string value)
        {
            var pascalCase = ToPropertyName(value);
            return "_" + char.ToLowerInvariant(pascalCase[0]) + pascalCase[1..];
        }

        private static string ToPropertyName(string value)
        {
            return value.Split(new[] { "_" }, StringSplitOptions.RemoveEmptyEntries)
             .Select(s => char.ToUpperInvariant(s[0]) + s[1..])
             .Aggregate(string.Empty, (s1, s2) => s1 + s2);
        }

        private static string ToArgumentName(string value)
        {
            var pascalCase = ToPropertyName(value);
            return char.ToLowerInvariant(pascalCase[0]) + pascalCase[1..];
        }

        private static ParameterLocation GetParameterLocation(Method method, MethodParameter parameter)
        {
            if (parameter.Location != ParameterLocation.Default)
            {
                return parameter.Location;
            }

            if (method.UrlTemplate.Contains($":{parameter.Name}/", StringComparison.Ordinal) || method.UrlTemplate.EndsWith($":{parameter.Name}", StringComparison.Ordinal))
                return ParameterLocation.Url;

            return method.MethodType switch
            {
                MethodType.Get or MethodType.GetPaged => ParameterLocation.Url,
                MethodType.Put or MethodType.Post or MethodType.Delete => ParameterLocation.Body,
                _ => throw new ArgumentOutOfRangeException(nameof(method)),
            };
        }

        private static TypeReference GetPropertyTypeRef(ModelRef modelRef)
        {
            var typeRef = (TypeReference)modelRef;
            if (modelRef.IsCollection)
            {
                typeRef = new TypeReference(typeof(IReadOnlyList<>)).MakeGeneric(typeRef);
            }

            return typeRef;
        }

        private static TypeReference GetArgumentTypeRef(MethodParameter param)
        {
            var typeRef = (TypeReference)param.Type;
            if (param.Type.IsCollection)
            {
                typeRef = new TypeReference(typeof(IEnumerable<>)).MakeGeneric(typeRef);
            }

            if (!param.IsRequired)
            {
                typeRef = typeRef.MakeNullable();
            }

            return typeRef;
        }
    }
}
